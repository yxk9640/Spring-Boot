import ClientPlugin from "@hilla/generator-typescript-plugin-client";
import equal from "fast-deep-equal";
import { OpenAPIV3 } from "openapi-types";
import ts, {} from "typescript";
import EndpointMethodRequestBodyProcessor from "./EndpointMethodRequestBodyProcessor.js";
import EndpointMethodResponseProcessor from "./EndpointMethodResponseProcessor.js";
const INIT_TYPE_NAME = "EndpointRequestInit";
const HILLA_FRONTEND_NAME = "@hilla/frontend";
class EndpointMethodOperationProcessor {
  static createProcessor(httpMethod, endpointName, endpointMethodName, operation, dependencies, owner) {
    switch (httpMethod) {
      case OpenAPIV3.HttpMethods.POST:
        return new EndpointMethodOperationPOSTProcessor(
          endpointName,
          endpointMethodName,
          operation,
          dependencies,
          owner
        );
      default:
        owner.logger.warn(`Processing ${httpMethod.toUpperCase()} currently is not supported`);
        return void 0;
    }
  }
}
class EndpointMethodOperationPOSTProcessor extends EndpointMethodOperationProcessor {
  #dependencies;
  #endpointMethodName;
  #endpointName;
  #operation;
  #owner;
  constructor(endpointName, endpointMethodName, operation, dependencies, owner) {
    super();
    this.#owner = owner;
    this.#dependencies = dependencies;
    this.#endpointName = endpointName;
    this.#endpointMethodName = endpointMethodName;
    this.#operation = operation;
  }
  async process(outputDir) {
    const { exports, imports, paths } = this.#dependencies;
    this.#owner.logger.debug(`${this.#endpointName}.${this.#endpointMethodName} - processing POST method`);
    const initTypeIdentifier = imports.named.getIdentifier(
      paths.createBareModulePath(HILLA_FRONTEND_NAME),
      INIT_TYPE_NAME
    );
    const { initParam, packedParameters, parameters } = new EndpointMethodRequestBodyProcessor(
      this.#operation.requestBody,
      this.#dependencies,
      this.#owner,
      initTypeIdentifier
    ).process();
    const methodIdentifier = exports.named.add(this.#endpointMethodName);
    const clientLibIdentifier = imports.default.getIdentifier(
      paths.createRelativePath(await ClientPlugin.getClientFileName(outputDir))
    );
    const callExpression = ts.factory.createCallExpression(
      ts.factory.createPropertyAccessExpression(clientLibIdentifier, ts.factory.createIdentifier("call")),
      void 0,
      [
        ts.factory.createStringLiteral(this.#endpointName),
        ts.factory.createStringLiteral(this.#endpointMethodName),
        packedParameters,
        initParam
      ].filter(Boolean)
    );
    const responseType = this.#prepareResponseType();
    return ts.factory.createFunctionDeclaration(
      [ts.factory.createToken(ts.SyntaxKind.AsyncKeyword)],
      void 0,
      methodIdentifier,
      void 0,
      parameters,
      ts.factory.createTypeReferenceNode("Promise", [responseType]),
      ts.factory.createBlock([ts.factory.createReturnStatement(callExpression)])
    );
  }
  #prepareResponseType() {
    this.#owner.logger.debug(`${this.#endpointName}.${this.#endpointMethodName} POST - processing response type`);
    const responseTypes = Object.entries(this.#operation.responses).flatMap(
      ([code, response]) => new EndpointMethodResponseProcessor(code, response, this.#dependencies, this.#owner).process()
    ).filter((value, index, arr) => arr.findIndex((v) => equal(v, value)) === index);
    if (responseTypes.length === 0) {
      return ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword);
    }
    return ts.factory.createUnionTypeNode(responseTypes);
  }
}
export {
  HILLA_FRONTEND_NAME,
  INIT_TYPE_NAME,
  EndpointMethodOperationProcessor as default
};
//# sourceMappingURL=EndpointMethodOperationProcessor.js.map
