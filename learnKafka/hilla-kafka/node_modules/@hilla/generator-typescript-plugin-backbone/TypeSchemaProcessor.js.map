{
  "version": 3,
  "sources": ["src/TypeSchemaProcessor.ts"],
  "sourcesContent": ["import {\n  type ArraySchema,\n  convertReferenceSchemaToPath,\n  convertReferenceSchemaToSpecifier,\n  decomposeSchema,\n  isArraySchema,\n  isBooleanSchema,\n  isComposedSchema,\n  isIntegerSchema,\n  isMapSchema,\n  isNullableSchema,\n  isNumberSchema,\n  isReferenceSchema,\n  isStringSchema,\n  type MapSchema,\n  type NonComposedSchema,\n  type ReferenceSchema,\n  type Schema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport type DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';\nimport ts, { type TypeNode } from 'typescript';\n\nfunction createBoolean(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n}\n\nfunction createNumber(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n}\n\nfunction createString(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n}\n\nfunction createUndefined(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n}\n\nfunction createUnknown(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n}\n\nfunction unwrapPossiblyNullableSchema(schema: Schema): NonComposedSchema {\n  if (isComposedSchema(schema)) {\n    const [result] = decomposeSchema(schema);\n\n    return result as NonComposedSchema;\n  }\n\n  return schema as NonComposedSchema;\n}\n\nexport default class TypeSchemaProcessor {\n  declare ['constructor']: typeof TypeSchemaProcessor;\n  readonly #dependencies: DependencyManager;\n  readonly #schema: Schema;\n\n  constructor(schema: Schema, dependencies: DependencyManager) {\n    this.#schema = schema;\n    this.#dependencies = dependencies;\n  }\n\n  process(): readonly TypeNode[] {\n    let node: TypeNode;\n\n    const unwrappedSchema = unwrapPossiblyNullableSchema(this.#schema);\n\n    if (isReferenceSchema(unwrappedSchema)) {\n      node = this.#processReference(unwrappedSchema);\n    } else if (isArraySchema(unwrappedSchema)) {\n      node = this.#processArray(unwrappedSchema);\n    } else if (isMapSchema(unwrappedSchema)) {\n      node = this.#processMap(unwrappedSchema);\n    } else if (isBooleanSchema(unwrappedSchema)) {\n      node = createBoolean();\n    } else if (isIntegerSchema(unwrappedSchema) || isNumberSchema(unwrappedSchema)) {\n      node = createNumber();\n    } else if (isStringSchema(unwrappedSchema)) {\n      node = createString();\n    } else {\n      node = createUnknown();\n    }\n\n    return isNullableSchema(this.#schema) ? [node, createUndefined()] : [node];\n  }\n\n  #processArray(schema: ArraySchema): TypeNode {\n    const nodes = new TypeSchemaProcessor(schema.items, this.#dependencies).process();\n\n    return ts.factory.createTypeReferenceNode('Array', [ts.factory.createUnionTypeNode(nodes)]);\n  }\n\n  #processMap({ additionalProperties: valuesType }: MapSchema): TypeNode {\n    let valuesTypeNode: TypeNode;\n\n    if (typeof valuesType !== 'boolean') {\n      const nodes = new TypeSchemaProcessor(valuesType, this.#dependencies).process();\n      valuesTypeNode = ts.factory.createUnionTypeNode(nodes);\n    } else {\n      valuesTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n    }\n\n    return ts.factory.createTypeReferenceNode('Record', [\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n      valuesTypeNode,\n    ]);\n  }\n\n  #processReference(schema: ReferenceSchema): TypeNode {\n    const { imports, paths } = this.#dependencies;\n\n    const specifier = convertReferenceSchemaToSpecifier(schema);\n    const path = paths.createRelativePath(convertReferenceSchemaToPath(schema));\n\n    const identifier = imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);\n\n    return ts.factory.createTypeReferenceNode(identifier);\n  }\n}\n"],
  "mappings": "AAAA;AAAA,EAEE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OAKK;AAEP,OAAO,YAA2B;AAElC,SAAS,gBAA0B;AACjC,SAAO,GAAG,QAAQ,sBAAsB,GAAG,WAAW,cAAc;AACtE;AAEA,SAAS,eAAyB;AAChC,SAAO,GAAG,QAAQ,sBAAsB,GAAG,WAAW,aAAa;AACrE;AAEA,SAAS,eAAyB;AAChC,SAAO,GAAG,QAAQ,sBAAsB,GAAG,WAAW,aAAa;AACrE;AAEA,SAAS,kBAA4B;AACnC,SAAO,GAAG,QAAQ,sBAAsB,GAAG,WAAW,gBAAgB;AACxE;AAEA,SAAS,gBAA0B;AACjC,SAAO,GAAG,QAAQ,sBAAsB,GAAG,WAAW,cAAc;AACtE;AAEA,SAAS,6BAA6B,QAAmC;AACvE,MAAI,iBAAiB,MAAM,GAAG;AAC5B,UAAM,CAAC,MAAM,IAAI,gBAAgB,MAAM;AAEvC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,MAAO,oBAAkC;AAAA,EAE9B;AAAA,EACA;AAAA,EAET,YAAY,QAAgB,cAAiC;AAC3D,SAAK,UAAU;AACf,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,UAA+B;AAC7B,QAAI;AAEJ,UAAM,kBAAkB,6BAA6B,KAAK,OAAO;AAEjE,QAAI,kBAAkB,eAAe,GAAG;AACtC,aAAO,KAAK,kBAAkB,eAAe;AAAA,IAC/C,WAAW,cAAc,eAAe,GAAG;AACzC,aAAO,KAAK,cAAc,eAAe;AAAA,IAC3C,WAAW,YAAY,eAAe,GAAG;AACvC,aAAO,KAAK,YAAY,eAAe;AAAA,IACzC,WAAW,gBAAgB,eAAe,GAAG;AAC3C,aAAO,cAAc;AAAA,IACvB,WAAW,gBAAgB,eAAe,KAAK,eAAe,eAAe,GAAG;AAC9E,aAAO,aAAa;AAAA,IACtB,WAAW,eAAe,eAAe,GAAG;AAC1C,aAAO,aAAa;AAAA,IACtB,OAAO;AACL,aAAO,cAAc;AAAA,IACvB;AAEA,WAAO,iBAAiB,KAAK,OAAO,IAAI,CAAC,MAAM,gBAAgB,CAAC,IAAI,CAAC,IAAI;AAAA,EAC3E;AAAA,EAEA,cAAc,QAA+B;AAC3C,UAAM,QAAQ,IAAI,oBAAoB,OAAO,OAAO,KAAK,aAAa,EAAE,QAAQ;AAEhF,WAAO,GAAG,QAAQ,wBAAwB,SAAS,CAAC,GAAG,QAAQ,oBAAoB,KAAK,CAAC,CAAC;AAAA,EAC5F;AAAA,EAEA,YAAY,EAAE,sBAAsB,WAAW,GAAwB;AACrE,QAAI;AAEJ,QAAI,OAAO,eAAe,WAAW;AACnC,YAAM,QAAQ,IAAI,oBAAoB,YAAY,KAAK,aAAa,EAAE,QAAQ;AAC9E,uBAAiB,GAAG,QAAQ,oBAAoB,KAAK;AAAA,IACvD,OAAO;AACL,uBAAiB,GAAG,QAAQ,sBAAsB,GAAG,WAAW,cAAc;AAAA,IAChF;AAEA,WAAO,GAAG,QAAQ,wBAAwB,UAAU;AAAA,MAClD,GAAG,QAAQ,sBAAsB,GAAG,WAAW,aAAa;AAAA,MAC5D;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,kBAAkB,QAAmC;AACnD,UAAM,EAAE,SAAS,MAAM,IAAI,KAAK;AAEhC,UAAM,YAAY,kCAAkC,MAAM;AAC1D,UAAM,OAAO,MAAM,mBAAmB,6BAA6B,MAAM,CAAC;AAE1E,UAAM,aAAa,QAAQ,QAAQ,cAAc,IAAI,KAAK,QAAQ,QAAQ,IAAI,MAAM,WAAW,IAAI;AAEnG,WAAO,GAAG,QAAQ,wBAAwB,UAAU;AAAA,EACtD;AACF;",
  "names": []
}
