import { constants } from "node:fs";
import { access, mkdir, readFile, rm, writeFile } from "node:fs/promises";
import { createRequire } from "node:module";
import { dirname, isAbsolute, join, resolve } from "node:path";
import { pathToFileURL } from "node:url";
import Plugin, {} from "@hilla/generator-typescript-core/Plugin.js";
import GeneratorIOException from "./GeneratorIOException.js";
const require2 = createRequire(import.meta.url);
class GeneratorIO {
  static INDEX_FILENAME = "generated-file-list.txt";
  cwd;
  #logger;
  #outputDir;
  constructor(outputDir, logger) {
    this.cwd = process.cwd();
    this.#outputDir = isAbsolute(outputDir) ? outputDir : resolve(this.cwd, outputDir);
    this.#logger = logger;
    logger.global.debug(`Output directory: ${this.#outputDir}`);
  }
  /**
   * Gets the list of files generated the last time. The info is found in {@link INDEX_FILENAME}.
   * @returns a list of files that have been generated by us
   */
  async getGeneratedFiles() {
    const files = /* @__PURE__ */ new Set();
    try {
      const indexFileContents = await this.read(this.resolveGeneratedFile(this.constructor.INDEX_FILENAME));
      indexFileContents.split("\n").filter((n) => n.length).forEach((fileName) => files.add(fileName));
    } catch (e) {
      if (!(e instanceof Error && "code" in e && e.code === "ENOENT")) {
        throw e;
      }
    }
    return files;
  }
  /**
   * Cleans the output directory by keeping the generated files and deleting the rest of the given files.
   *
   * @returns a set containing deleted filenames
   */
  async cleanOutputDir(generatedFiles, filesToDelete) {
    this.#logger.global.debug(`Cleaning ${this.#outputDir}`);
    await mkdir(this.#outputDir, { recursive: true });
    generatedFiles.forEach((filename) => {
      this.#logger.global.debug(`File ${filename} was re-written, should not delete it`);
      filesToDelete.delete(filename);
    });
    const deletedFiles = new Set(
      await Promise.all(
        [...filesToDelete].map(async (filename) => {
          const resolved = this.resolveGeneratedFile(filename);
          if (await this.exists(resolved)) {
            this.#logger.global.debug(`Deleting file ${filename}.`);
            await rm(resolved);
          }
          return filename;
        })
      )
    );
    return deletedFiles;
  }
  async createFileIndex(filenames) {
    await this.write(this.constructor.INDEX_FILENAME, filenames.join("\n"));
  }
  async writeGeneratedFiles(files) {
    await this.createFileIndex(files.map((file) => file.name));
    this.#logger.global.debug(`created index`);
    return Promise.all(
      files.map(async (file) => {
        const newFileContent = await file.text();
        let oldFileContent;
        try {
          oldFileContent = await this.read(this.resolveGeneratedFile(file.name));
        } catch (_e) {
        }
        if (newFileContent !== oldFileContent) {
          this.#logger.global.debug(`writing file ${file.name}`);
          await this.write(file.name, await file.text());
        } else {
          this.#logger.global.debug(`File ${file.name} stayed the same`);
        }
        return file.name;
      })
    );
  }
  /**
   * Checks that a file exists (is visible)
   * @param path - the file path to check
   */
  // eslint-disable-next-line class-methods-use-this
  async exists(path) {
    try {
      await access(path, constants.F_OK);
      return true;
    } catch {
      return false;
    }
  }
  async loadPlugin(modulePath) {
    this.#logger.global.debug(`Loading plugin: ${modulePath}`);
    const module = await import(pathToFileURL(require2.resolve(modulePath)).toString());
    const ctr = module.default;
    if (!Object.prototype.isPrototypeOf.call(Plugin, ctr)) {
      throw new GeneratorIOException(`Plugin '${modulePath}' is not an instance of a Plugin class`);
    }
    return ctr;
  }
  resolveGeneratedFile(filename) {
    return resolve(this.#outputDir, filename);
  }
  async read(path) {
    this.#logger.global.debug(`Reading file: ${path}`);
    return readFile(path, "utf8");
  }
  async write(filename, content) {
    const filePath = join(this.#outputDir, filename);
    this.#logger.global.debug(`Writing file ${filePath}.`);
    const dir = dirname(filePath);
    await mkdir(dir, { recursive: true });
    return writeFile(filePath, content, "utf-8");
  }
}
export {
  GeneratorIO as default
};
//# sourceMappingURL=GeneratorIO.js.map
