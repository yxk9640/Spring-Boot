{
  "version": 3,
  "sources": ["src/Connect.ts"],
  "sourcesContent": ["import type { ReactiveControllerHost } from '@lit/reactive-element';\nimport { ConnectionIndicator, ConnectionState } from '@vaadin/common-frontend';\nimport { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils.js';\nimport {\n  EndpointError,\n  EndpointResponseError,\n  EndpointValidationError,\n  ForbiddenResponseError,\n  UnauthorizedResponseError,\n  type ValidationErrorData,\n} from './EndpointErrors.js';\nimport { FluxConnection } from './FluxConnection.js';\nimport type { VaadinWindow } from './types.js';\n\nconst $wnd = window as VaadinWindow;\n\n$wnd.Vaadin ??= {};\n$wnd.Vaadin.registrations ??= [];\n$wnd.Vaadin.registrations.push({\n  is: 'endpoint',\n});\n\nexport type MaybePromise<T> = Promise<T> | T;\n\n/**\n * Represents the connection to and endpoint returning a subscription rather than a value.\n */\nexport interface Subscription<T> {\n  /** Cancels the subscription.  No values are made available after calling this. */\n  cancel(): void;\n\n  /*\n   * Binds to the given context (element) so that when the context is deactivated (element detached), the subscription is closed.\n   */\n  context(context: ReactiveControllerHost): Subscription<T>;\n\n  /** Called when the subscription has completed. No values are made available after calling this. */\n  onComplete(callback: () => void): Subscription<T>;\n\n  /** Called when an exception occured in the subscription. */\n  onError(callback: () => void): Subscription<T>;\n\n  /** Called when a new value is available. */\n  onNext(callback: (value: T) => void): Subscription<T>;\n}\n\ninterface ConnectExceptionData {\n  detail?: any;\n  message: string;\n  type: string;\n  validationErrorData?: ValidationErrorData[];\n}\n\n/**\n * Throws a TypeError if the response is not 200 OK.\n * @param response - The response to assert.\n */\nconst assertResponseIsOk = async (response: Response): Promise<void> => {\n  if (!response.ok) {\n    const errorText = await response.text();\n    let errorJson: ConnectExceptionData | null;\n    try {\n      errorJson = JSON.parse(errorText);\n    } catch (ignored) {\n      // not a json\n      errorJson = null;\n    }\n\n    const message =\n      errorJson?.message ??\n      (errorText.length > 0\n        ? errorText\n        : `expected \"200 OK\" response, but got ${response.status} ${response.statusText}`);\n    const type = errorJson?.type;\n\n    if (errorJson?.validationErrorData) {\n      throw new EndpointValidationError(message, errorJson.validationErrorData, type);\n    }\n\n    if (type) {\n      throw new EndpointError(message, type, errorJson?.detail);\n    }\n\n    switch (response.status) {\n      case 401:\n        throw new UnauthorizedResponseError(message, response);\n      case 403:\n        throw new ForbiddenResponseError(message, response);\n      default:\n        throw new EndpointResponseError(message, response);\n    }\n  }\n};\n\n/**\n * The `ConnectClient` constructor options.\n */\nexport interface ConnectClientOptions {\n  /**\n   * The `middlewares` property value.\n   */\n  middlewares?: Middleware[];\n  /**\n   * The `prefix` property value.\n   */\n  prefix?: string;\n}\n\nexport interface EndpointCallMetaInfo {\n  /**\n   * The endpoint name.\n   */\n  endpoint: string;\n\n  /**\n   * The method name to call on in the endpoint class.\n   */\n  method: string;\n\n  /**\n   * Optional object with method call arguments.\n   */\n  params?: Record<string, unknown>;\n}\n\n/**\n * An object with the call arguments and the related Request instance.\n * See also {@link ConnectClient.call | the call() method in ConnectClient}.\n */\nexport interface MiddlewareContext extends EndpointCallMetaInfo {\n  /**\n   * The Fetch API Request object reflecting the other properties.\n   */\n  request: Request;\n}\n\n/**\n * An async middleware callback that invokes the next middleware in the chain\n * or makes the actual request.\n * @param context - The information about the call and request\n */\nexport type MiddlewareNext = (context: MiddlewareContext) => MaybePromise<Response>;\n\n/**\n * An interface that allows defining a middleware as a class.\n */\nexport interface MiddlewareClass {\n  /**\n   * @param context - The information about the call and request\n   * @param next - Invokes the next in the call chain\n   */\n  invoke(context: MiddlewareContext, next: MiddlewareNext): MaybePromise<Response>;\n}\n\n/**\n * An async callback function that can intercept the request and response\n * of a call.\n */\nexport type MiddlewareFunction = (context: MiddlewareContext, next: MiddlewareNext) => MaybePromise<Response>;\n\n/**\n * An async callback that can intercept the request and response\n * of a call, could be either a function or a class.\n */\nexport type Middleware = MiddlewareClass | MiddlewareFunction;\n\nfunction isFlowLoaded(): boolean {\n  return $wnd.Vaadin?.Flow?.clients?.TypeScript !== undefined;\n}\n\n/**\n * A list of parameters supported by {@link ConnectClient.call | the call() method in ConnectClient}.\n */\nexport interface EndpointRequestInit {\n  /**\n   * An AbortSignal to set request's signal.\n   */\n  signal?: AbortSignal | null;\n}\n\n/**\n * A low-level network calling utility. It stores\n * a prefix and facilitates remote calls to endpoint class methods\n * on the Hilla backend.\n *\n * Example usage:\n *\n * ```js\n * const client = new ConnectClient();\n * const responseData = await client.call('MyEndpoint', 'myMethod');\n * ```\n *\n * ### Prefix\n *\n * The client supports an `prefix` constructor option:\n * ```js\n * const client = new ConnectClient({prefix: '/my-connect-prefix'});\n * ```\n *\n * The default prefix is '/connect'.\n *\n */\nexport class ConnectClient {\n  /**\n   * The array of middlewares that are invoked during a call.\n   */\n  middlewares: Middleware[] = [];\n  /**\n   * The Hilla endpoint prefix\n   */\n  prefix = '/connect';\n\n  #fluxConnection?: FluxConnection;\n\n  /**\n   * @param options - Constructor options.\n   */\n  constructor(options: ConnectClientOptions = {}) {\n    if (options.prefix) {\n      this.prefix = options.prefix;\n    }\n\n    if (options.middlewares) {\n      this.middlewares = options.middlewares;\n    }\n\n    // add connection indicator to DOM\n    ConnectionIndicator.create();\n\n    // Listen to browser online/offline events and update the loading indicator accordingly.\n    // Note: if Flow.ts is loaded, it instead handles the state transitions.\n    addEventListener('online', () => {\n      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTED;\n      }\n    });\n    addEventListener('offline', () => {\n      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {\n        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;\n      }\n    });\n  }\n\n  /**\n   * Gets a representation of the underlying persistent network connection used for subscribing to Flux type endpoint\n   * methods.\n   */\n  get fluxConnection(): FluxConnection {\n    if (!this.#fluxConnection) {\n      this.#fluxConnection = new FluxConnection(this.prefix);\n    }\n    return this.#fluxConnection;\n  }\n\n  /**\n   * Calls the given endpoint method defined using the endpoint and method\n   * parameters with the parameters given as params.\n   * Asynchronously returns the parsed JSON response data.\n   *\n   * @param endpoint - Endpoint name.\n   * @param method - Method name to call in the endpoint class.\n   * @param params - Optional parameters to pass to the method.\n   * @param init - Optional parameters for the request\n   * @returns Decoded JSON response data.\n   */\n  async call(\n    endpoint: string,\n    method: string,\n    params?: Record<string, unknown>,\n    init?: EndpointRequestInit,\n  ): Promise<any> {\n    if (arguments.length < 2) {\n      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);\n    }\n\n    const csrfHeaders = getCsrfTokenHeadersForEndpointRequest(document);\n    const headers: Record<string, string> = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      ...csrfHeaders,\n    };\n\n    const request = new Request(`${this.prefix}/${endpoint}/${method}`, {\n      body:\n        params !== undefined ? JSON.stringify(params, (_, value) => (value === undefined ? null : value)) : undefined,\n      headers,\n      method: 'POST',\n    });\n\n    // The middleware `context`, includes the call arguments and the request\n    // constructed from them\n    const initialContext: MiddlewareContext = {\n      endpoint,\n      method,\n      params,\n      request,\n    };\n\n    // The internal middleware to assert and parse the response. The internal\n    // response handling should come last after the other middlewares are done\n    // with processing the response. That is why this middleware is first\n    // in the final middlewares array.\n    async function responseHandlerMiddleware(context: MiddlewareContext, next: MiddlewareNext): Promise<Response> {\n      const response = await next(context);\n      await assertResponseIsOk(response);\n      const text = await response.text();\n      return JSON.parse(text, (_, value: any) => (value === null ? undefined : value));\n    }\n\n    // The actual fetch call itself is expressed as a middleware\n    // chain item for our convenience. Always having an ending of the chain\n    // this way makes the folding down below more concise.\n    async function fetchNext(context: MiddlewareContext) {\n      $wnd.Vaadin?.connectionState?.loadingStarted();\n      try {\n        const response = await fetch(context.request, { signal: init?.signal });\n        $wnd.Vaadin?.connectionState?.loadingFinished();\n        return response;\n      } catch (error: unknown) {\n        // don't bother about connections aborted by purpose\n        if (error instanceof Error && error.name === 'AbortError') {\n          $wnd.Vaadin?.connectionState?.loadingFinished();\n        } else {\n          $wnd.Vaadin?.connectionState?.loadingFailed();\n        }\n        return Promise.reject(error);\n      }\n    }\n\n    // Assemble the final middlewares array from internal\n    // and external middlewares\n    const middlewares = [responseHandlerMiddleware as Middleware, ...this.middlewares];\n\n    // Fold the final middlewares array into a single function\n    const chain = middlewares.reduceRight(\n      (next: MiddlewareNext, middleware) =>\n        // Compose and return the new chain step, that takes the context and\n        // invokes the current middleware with the context and the further chain\n        // as the next argument\n        async (context) => {\n          if (typeof middleware === 'function') {\n            return middleware(context, next);\n          }\n          return middleware.invoke(context, next);\n        },\n      // Initialize reduceRight the accumulator with `fetchNext`\n      fetchNext,\n    );\n\n    // Invoke all the folded async middlewares and return\n    return chain(initialContext);\n  }\n\n  /**\n   * Subscribes to the given method defined using the endpoint and method\n   * parameters with the parameters given as params. The method must return a\n   * compatible type such as a Flux.\n   * Returns a subscription that is used to fetch values as they become available.\n   *\n   * @param endpoint - Endpoint name.\n   * @param method - Method name to call in the endpoint class.\n   * @param params - Optional parameters to pass to the method.\n   * @returns A subscription used to handles values as they become available.\n   */\n  subscribe(endpoint: string, method: string, params?: any): Subscription<any> {\n    return this.fluxConnection.subscribe(endpoint, method, params ? Object.values(params) : []);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
