import atmosphere from "atmosphere.js";
import { getCsrfTokenHeadersForEndpointRequest } from "./CsrfUtils.js";
import {
  isClientMessage
} from "./FluxMessages.js";
var State = /* @__PURE__ */ ((State2) => {
  State2["ACTIVE"] = "active";
  State2["INACTIVE"] = "inactive";
  return State2;
})(State || {});
class FluxConnection extends EventTarget {
  state = "inactive" /* INACTIVE */;
  #endpointInfos = /* @__PURE__ */ new Map();
  #nextId = 0;
  #onCompleteCallbacks = /* @__PURE__ */ new Map();
  #onErrorCallbacks = /* @__PURE__ */ new Map();
  #onNextCallbacks = /* @__PURE__ */ new Map();
  #pendingMessages = [];
  #socket;
  constructor(connectPrefix) {
    super();
    this.#connectWebsocket(connectPrefix.replace(/connect$/u, ""));
  }
  /**
   * Subscribes to the flux returned by the given endpoint name + method name using the given parameters.
   *
   * @param endpointName - the endpoint to connect to
   * @param methodName - the method in the endpoint to connect to
   * @param parameters - the parameters to use
   * @returns a subscription
   */
  subscribe(endpointName, methodName, parameters) {
    const id = this.#nextId.toString();
    this.#nextId += 1;
    const params = parameters ?? [];
    const msg = { "@type": "subscribe", endpointName, id, methodName, params };
    const endpointInfo = `${endpointName}.${methodName}(${JSON.stringify(params)})`;
    this.#send(msg);
    this.#endpointInfos.set(id, endpointInfo);
    const hillaSubscription = {
      cancel: () => {
        if (!this.#endpointInfos.has(id)) {
          return;
        }
        const closeMessage = { "@type": "unsubscribe", id };
        this.#send(closeMessage);
        this.#removeSubscription(id);
      },
      context(context) {
        context.addController({
          hostDisconnected() {
            hillaSubscription.cancel();
          }
        });
        return hillaSubscription;
      },
      onComplete: (callback) => {
        this.#onCompleteCallbacks.set(id, callback);
        return hillaSubscription;
      },
      onError: (callback) => {
        this.#onErrorCallbacks.set(id, callback);
        return hillaSubscription;
      },
      onNext: (callback) => {
        this.#onNextCallbacks.set(id, callback);
        return hillaSubscription;
      }
    };
    return hillaSubscription;
  }
  #connectWebsocket(prefix) {
    const extraHeaders = getCsrfTokenHeadersForEndpointRequest(document);
    const pushUrl = "HILLA/push";
    const url = prefix.length === 0 ? pushUrl : (prefix.endsWith("/") ? prefix : `${prefix}/`) + pushUrl;
    this.#socket = atmosphere.subscribe?.({
      contentType: "application/json; charset=UTF-8",
      enableProtocol: true,
      fallbackTransport: "long-polling",
      headers: extraHeaders,
      maxReconnectOnClose: 1e7,
      onClose: (_) => {
        if (this.state === "active" /* ACTIVE */) {
          this.state = "inactive" /* INACTIVE */;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: false } }));
        }
      },
      onError: (response) => {
        console.error("error in push communication", response);
      },
      onMessage: (response) => {
        if (response.responseBody) {
          this.#handleMessage(JSON.parse(response.responseBody));
        }
      },
      onOpen: (_response) => {
        if (this.state === "inactive" /* INACTIVE */) {
          this.state = "active" /* ACTIVE */;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
          this.#sendPendingMessages();
        }
      },
      onReopen: (_response) => {
        if (this.state === "inactive" /* INACTIVE */) {
          this.state = "active" /* ACTIVE */;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
          this.#sendPendingMessages();
        }
      },
      reconnectInterval: 5e3,
      timeout: -1,
      trackMessageLength: true,
      transport: "websocket",
      url
    });
  }
  #handleMessage(message) {
    if (isClientMessage(message)) {
      const { id } = message;
      const endpointInfo = this.#endpointInfos.get(id) ?? "unknown";
      if (message["@type"] === "update") {
        const callback = this.#onNextCallbacks.get(id);
        if (callback) {
          callback(message.item);
        }
      } else if (message["@type"] === "complete") {
        this.#onCompleteCallbacks.get(id)?.();
        this.#removeSubscription(id);
      } else {
        const callback = this.#onErrorCallbacks.get(id);
        if (callback) {
          callback();
        }
        this.#removeSubscription(id);
        if (!callback) {
          throw new Error(`Error in ${endpointInfo}: ${message.message}`);
        }
      }
    } else {
      throw new Error(`Unknown message from server: ${String(message)}`);
    }
  }
  #removeSubscription(id) {
    this.#onNextCallbacks.delete(id);
    this.#onCompleteCallbacks.delete(id);
    this.#onErrorCallbacks.delete(id);
    this.#endpointInfos.delete(id);
  }
  #send(message) {
    if (this.state === "inactive" /* INACTIVE */) {
      this.#pendingMessages.push(message);
    } else {
      this.#socket?.push?.(JSON.stringify(message));
    }
  }
  #sendPendingMessages() {
    this.#pendingMessages.forEach((msg) => this.#send(msg));
    this.#pendingMessages = [];
  }
}
export {
  FluxConnection,
  State
};
//# sourceMappingURL=FluxConnection.js.map
