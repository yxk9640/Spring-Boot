import { ConnectionIndicator, ConnectionState } from "@vaadin/common-frontend";
import { getCsrfTokenHeadersForEndpointRequest } from "./CsrfUtils.js";
import {
  EndpointError,
  EndpointResponseError,
  EndpointValidationError,
  ForbiddenResponseError,
  UnauthorizedResponseError
} from "./EndpointErrors.js";
import { FluxConnection } from "./FluxConnection.js";
const $wnd = window;
$wnd.Vaadin ??= {};
$wnd.Vaadin.registrations ??= [];
$wnd.Vaadin.registrations.push({
  is: "endpoint"
});
const assertResponseIsOk = async (response) => {
  if (!response.ok) {
    const errorText = await response.text();
    let errorJson;
    try {
      errorJson = JSON.parse(errorText);
    } catch (ignored) {
      errorJson = null;
    }
    const message = errorJson?.message ?? (errorText.length > 0 ? errorText : `expected "200 OK" response, but got ${response.status} ${response.statusText}`);
    const type = errorJson?.type;
    if (errorJson?.validationErrorData) {
      throw new EndpointValidationError(message, errorJson.validationErrorData, type);
    }
    if (type) {
      throw new EndpointError(message, type, errorJson?.detail);
    }
    switch (response.status) {
      case 401:
        throw new UnauthorizedResponseError(message, response);
      case 403:
        throw new ForbiddenResponseError(message, response);
      default:
        throw new EndpointResponseError(message, response);
    }
  }
};
function isFlowLoaded() {
  return $wnd.Vaadin?.Flow?.clients?.TypeScript !== void 0;
}
class ConnectClient {
  /**
   * The array of middlewares that are invoked during a call.
   */
  middlewares = [];
  /**
   * The Hilla endpoint prefix
   */
  prefix = "/connect";
  #fluxConnection;
  /**
   * @param options - Constructor options.
   */
  constructor(options = {}) {
    if (options.prefix) {
      this.prefix = options.prefix;
    }
    if (options.middlewares) {
      this.middlewares = options.middlewares;
    }
    ConnectionIndicator.create();
    addEventListener("online", () => {
      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {
        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTED;
      }
    });
    addEventListener("offline", () => {
      if (!isFlowLoaded() && $wnd.Vaadin?.connectionState) {
        $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;
      }
    });
  }
  /**
   * Gets a representation of the underlying persistent network connection used for subscribing to Flux type endpoint
   * methods.
   */
  get fluxConnection() {
    if (!this.#fluxConnection) {
      this.#fluxConnection = new FluxConnection(this.prefix);
    }
    return this.#fluxConnection;
  }
  /**
   * Calls the given endpoint method defined using the endpoint and method
   * parameters with the parameters given as params.
   * Asynchronously returns the parsed JSON response data.
   *
   * @param endpoint - Endpoint name.
   * @param method - Method name to call in the endpoint class.
   * @param params - Optional parameters to pass to the method.
   * @param init - Optional parameters for the request
   * @returns Decoded JSON response data.
   */
  async call(endpoint, method, params, init) {
    if (arguments.length < 2) {
      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);
    }
    const csrfHeaders = getCsrfTokenHeadersForEndpointRequest(document);
    const headers = {
      Accept: "application/json",
      "Content-Type": "application/json",
      ...csrfHeaders
    };
    const request = new Request(`${this.prefix}/${endpoint}/${method}`, {
      body: params !== void 0 ? JSON.stringify(params, (_, value) => value === void 0 ? null : value) : void 0,
      headers,
      method: "POST"
    });
    const initialContext = {
      endpoint,
      method,
      params,
      request
    };
    async function responseHandlerMiddleware(context, next) {
      const response = await next(context);
      await assertResponseIsOk(response);
      const text = await response.text();
      return JSON.parse(text, (_, value) => value === null ? void 0 : value);
    }
    async function fetchNext(context) {
      $wnd.Vaadin?.connectionState?.loadingStarted();
      try {
        const response = await fetch(context.request, { signal: init?.signal });
        $wnd.Vaadin?.connectionState?.loadingFinished();
        return response;
      } catch (error) {
        if (error instanceof Error && error.name === "AbortError") {
          $wnd.Vaadin?.connectionState?.loadingFinished();
        } else {
          $wnd.Vaadin?.connectionState?.loadingFailed();
        }
        return Promise.reject(error);
      }
    }
    const middlewares = [responseHandlerMiddleware, ...this.middlewares];
    const chain = middlewares.reduceRight(
      (next, middleware) => (
        // Compose and return the new chain step, that takes the context and
        // invokes the current middleware with the context and the further chain
        // as the next argument
        async (context) => {
          if (typeof middleware === "function") {
            return middleware(context, next);
          }
          return middleware.invoke(context, next);
        }
      ),
      // Initialize reduceRight the accumulator with `fetchNext`
      fetchNext
    );
    return chain(initialContext);
  }
  /**
   * Subscribes to the given method defined using the endpoint and method
   * parameters with the parameters given as params. The method must return a
   * compatible type such as a Flux.
   * Returns a subscription that is used to fetch values as they become available.
   *
   * @param endpoint - Endpoint name.
   * @param method - Method name to call in the endpoint class.
   * @param params - Optional parameters to pass to the method.
   * @returns A subscription used to handles values as they become available.
   */
  subscribe(endpoint, method, params) {
    return this.fluxConnection.subscribe(endpoint, method, params ? Object.values(params) : []);
  }
}
export {
  ConnectClient
};
//# sourceMappingURL=Connect.js.map
