import CookieManager from "./CookieManager.js";
import { getSpringCsrfInfo, getSpringCsrfTokenHeadersForAuthRequest, VAADIN_CSRF_HEADER } from "./CsrfUtils.js";
const JWT_COOKIE_NAME = "jwt.headerAndPayload";
function getSpringCsrfTokenFromResponseBody(body) {
  const doc = new DOMParser().parseFromString(body, "text/html");
  return getSpringCsrfInfo(doc);
}
function clearSpringCsrfMetaTags() {
  Array.from(document.head.querySelectorAll('meta[name="_csrf"], meta[name="_csrf_header"]')).forEach(
    (el) => el.remove()
  );
}
function updateSpringCsrfMetaTags(springCsrfInfo) {
  clearSpringCsrfMetaTags();
  const headerNameMeta = document.createElement("meta");
  headerNameMeta.name = "_csrf_header";
  headerNameMeta.content = springCsrfInfo._csrf_header;
  document.head.appendChild(headerNameMeta);
  const tokenMeta = document.createElement("meta");
  tokenMeta.name = "_csrf";
  tokenMeta.content = springCsrfInfo._csrf;
  document.head.appendChild(tokenMeta);
}
const getVaadinCsrfTokenFromResponseBody = (body) => {
  const match = /window\.Vaadin = \{TypeScript: \{"csrfToken":"([0-9a-zA-Z\\-]{36})"\}\};/iu.exec(body);
  return match ? match[1] : void 0;
};
async function updateCsrfTokensBasedOnResponse(response) {
  const responseText = await response.text();
  const token = getVaadinCsrfTokenFromResponseBody(responseText);
  const springCsrfTokenInfo = getSpringCsrfTokenFromResponseBody(responseText);
  updateSpringCsrfMetaTags(springCsrfTokenInfo);
  return token;
}
async function doLogout(logoutUrl, headers) {
  const response = await fetch(logoutUrl, { headers, method: "POST" });
  if (!response.ok) {
    throw new Error(`failed to logout with response ${response.status}`);
  }
  await updateCsrfTokensBasedOnResponse(response);
}
async function login(username, password, options) {
  try {
    const data = new FormData();
    data.append("username", username);
    data.append("password", password);
    const loginProcessingUrl = options?.loginProcessingUrl ?? "login";
    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);
    headers.source = "typescript";
    const response = await fetch(loginProcessingUrl, {
      body: data,
      headers,
      method: "POST"
    });
    const result = response.headers.get("Result");
    const savedUrl = response.headers.get("Saved-url") ?? void 0;
    const defaultUrl = response.headers.get("Default-url") ?? void 0;
    const loginSuccessful = response.ok && result === "success";
    if (loginSuccessful) {
      const vaadinCsrfToken = response.headers.get("Vaadin-CSRF") ?? void 0;
      const springCsrfHeader = response.headers.get("Spring-CSRF-header") ?? void 0;
      const springCsrfToken = response.headers.get("Spring-CSRF-token") ?? void 0;
      if (springCsrfHeader && springCsrfToken) {
        const springCsrfTokenInfo = {};
        springCsrfTokenInfo._csrf = springCsrfToken;
        springCsrfTokenInfo._csrf_header = springCsrfHeader;
        updateSpringCsrfMetaTags(springCsrfTokenInfo);
      }
      return {
        defaultUrl,
        error: false,
        redirectUrl: savedUrl,
        token: vaadinCsrfToken
      };
    }
    return {
      error: true,
      errorMessage: "Check that you have entered the correct username and password and try again.",
      errorTitle: "Incorrect username or password."
    };
  } catch (e) {
    if (e instanceof Error) {
      return {
        error: true,
        errorMessage: e.message,
        errorTitle: e.name
      };
    }
    throw e;
  }
}
async function logout(options) {
  const logoutUrl = options?.logoutUrl ?? "logout";
  try {
    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);
    await doLogout(logoutUrl, headers);
  } catch {
    try {
      const response = await fetch("?nocache");
      const responseText = await response.text();
      const doc = new DOMParser().parseFromString(responseText, "text/html");
      const headers = getSpringCsrfTokenHeadersForAuthRequest(doc);
      await doLogout(logoutUrl, headers);
    } catch (error) {
      clearSpringCsrfMetaTags();
      throw error;
    }
  } finally {
    CookieManager.remove(JWT_COOKIE_NAME);
  }
}
class InvalidSessionMiddleware {
  onInvalidSessionCallback;
  constructor(onInvalidSessionCallback) {
    this.onInvalidSessionCallback = onInvalidSessionCallback;
  }
  async invoke(context, next) {
    const clonedContext = { ...context };
    clonedContext.request = context.request.clone();
    const response = await next(context);
    if (response.status === 401) {
      const loginResult = await this.onInvalidSessionCallback();
      if (loginResult.token) {
        clonedContext.request.headers.set(VAADIN_CSRF_HEADER, loginResult.token);
        return next(clonedContext);
      }
    }
    return response;
  }
}
export {
  InvalidSessionMiddleware,
  login,
  logout
};
//# sourceMappingURL=Authentication.js.map
