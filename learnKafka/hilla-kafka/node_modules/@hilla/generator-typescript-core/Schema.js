import { convertFullyQualifiedNameToRelativePath, simplifyFullyQualifiedName } from "./utils.js";
function isReferenceSchema(schema) {
  return "$ref" in schema;
}
function isAnyOfRuleComposedSchema(schema) {
  return "anyOf" in schema;
}
function isAllOfRuleComposedSchema(schema) {
  return "allOf" in schema;
}
function isOneOfRuleComposedSchema(schema) {
  return "oneOf" in schema;
}
function isNotRuleComposedSchema(schema) {
  return "not" in schema;
}
function isComposedSchema(schema) {
  return isAnyOfRuleComposedSchema(schema) || isAllOfRuleComposedSchema(schema) || isOneOfRuleComposedSchema(schema) || isNotRuleComposedSchema(schema);
}
function isNonComposedSchema(schema) {
  return !isComposedSchema(schema);
}
function isNonComposedRegularSchema(schema) {
  return isNonComposedSchema(schema) && !isReferenceSchema(schema);
}
function isNullableSchema(schema) {
  return !isReferenceSchema(schema) && !!schema.nullable;
}
function decomposeSchema(schema) {
  if (isAnyOfRuleComposedSchema(schema)) {
    return schema.anyOf;
  }
  if (isAllOfRuleComposedSchema(schema)) {
    return schema.allOf;
  }
  if (isOneOfRuleComposedSchema(schema)) {
    return schema.oneOf;
  }
  return [schema.not];
}
function isArraySchema(schema) {
  return isNonComposedRegularSchema(schema) && schema.type === "array";
}
function isBooleanSchema(schema) {
  return isNonComposedRegularSchema(schema) && schema.type === "boolean";
}
function isIntegerSchema(schema) {
  return isNonComposedRegularSchema(schema) && schema.type === "integer";
}
function isNumberSchema(schema) {
  return isNonComposedRegularSchema(schema) && schema.type === "number";
}
function isObjectSchema(schema) {
  return isNonComposedRegularSchema(schema) && schema.type === "object";
}
function isStringSchema(schema) {
  return isNonComposedRegularSchema(schema) && schema.type === "string";
}
function isEnumSchema(schema) {
  return isStringSchema(schema) && !!schema.enum;
}
function isEmptyObject(schema) {
  return isObjectSchema(schema) && !schema.properties;
}
function isMapSchema(schema) {
  return isEmptyObject(schema) && !!schema.additionalProperties;
}
function convertReferenceSchemaToSpecifier({ $ref }) {
  return simplifyFullyQualifiedName($ref);
}
const COMPONENTS_SCHEMAS_REF_LENGTH = "#/components/schemas/".length;
function convertReferenceSchemaToPath({ $ref }) {
  return convertFullyQualifiedNameToRelativePath($ref.substring(COMPONENTS_SCHEMAS_REF_LENGTH));
}
function resolveReference(schemas, { $ref }) {
  if (schemas) {
    for (const [name, schema] of Object.entries(schemas)) {
      if ($ref.includes(name)) {
        return schema;
      }
    }
  }
  return void 0;
}
export {
  convertReferenceSchemaToPath,
  convertReferenceSchemaToSpecifier,
  decomposeSchema,
  isAllOfRuleComposedSchema,
  isAnyOfRuleComposedSchema,
  isArraySchema,
  isBooleanSchema,
  isComposedSchema,
  isEmptyObject,
  isEnumSchema,
  isIntegerSchema,
  isMapSchema,
  isNonComposedRegularSchema,
  isNonComposedSchema,
  isNotRuleComposedSchema,
  isNullableSchema,
  isNumberSchema,
  isObjectSchema,
  isOneOfRuleComposedSchema,
  isReferenceSchema,
  isStringSchema,
  resolveReference
};
//# sourceMappingURL=Schema.js.map
