{
  "version": 3,
  "sources": ["src/Schema.ts"],
  "sourcesContent": ["import type { OpenAPIV3 } from 'openapi-types';\nimport type { ReadonlyDeep } from 'type-fest';\nimport { convertFullyQualifiedNameToRelativePath, simplifyFullyQualifiedName, type Nullified } from './utils.js';\n\nexport type ReferenceSchema = ReadonlyDeep<OpenAPIV3.ReferenceObject>;\nexport type ArraySchema = ReadonlyDeep<OpenAPIV3.ArraySchemaObject>;\nexport type NonArraySchema = ReadonlyDeep<OpenAPIV3.NonArraySchemaObject>;\nexport type RegularSchema = ArraySchema | NonArraySchema;\n\nexport type NullableSchema = Readonly<Required<Pick<RegularSchema, 'nullable'>>> & RegularSchema;\n\nexport type AnyOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'anyOf'>>> & RegularSchema;\nexport type AllOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'allOf'>>> & RegularSchema;\nexport type OneOfRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'oneOf'>>> & RegularSchema;\nexport type NotRuleComposedSchema = Readonly<Required<Pick<RegularSchema, 'not'>>> & RegularSchema;\nexport type ComposedSchema =\n  | AllOfRuleComposedSchema\n  | AnyOfRuleComposedSchema\n  | NotRuleComposedSchema\n  | OneOfRuleComposedSchema;\n\nexport type NonComposedRegularSchema = Readonly<Nullified<RegularSchema, 'allOf' | 'anyOf' | 'oneOf'>> & RegularSchema;\nexport type NonComposedSchema = NonComposedRegularSchema | ReferenceSchema;\n\nexport type BooleanSchema = NonComposedRegularSchema & Readonly<{ type: 'boolean' }>;\nexport type IntegerSchema = NonComposedRegularSchema & Readonly<{ type: 'integer' }>;\nexport type NumberSchema = NonComposedRegularSchema & Readonly<{ type: 'number' }>;\nexport type ObjectSchema = NonComposedRegularSchema & Readonly<{ type: 'object' }>;\nexport type StringSchema = NonComposedRegularSchema & Readonly<{ type: 'string' }>;\n\nexport type EnumSchema = Readonly<Required<Pick<StringSchema, 'enum'>>> & StringSchema;\nexport type EmptyObjectSchema = ObjectSchema & Readonly<Nullified<ObjectSchema, 'properties'>>;\nexport type NonEmptyObjectSchema = ObjectSchema & Readonly<Required<Pick<ObjectSchema, 'properties'>>>;\nexport type MapSchema = EmptyObjectSchema & Readonly<Required<Pick<ObjectSchema, 'additionalProperties'>>>;\n\nexport type Schema = ReferenceSchema | RegularSchema;\n\nexport function isReferenceSchema(schema: Schema): schema is ReferenceSchema {\n  return '$ref' in schema;\n}\n\nexport function isAnyOfRuleComposedSchema(schema: Schema): schema is AnyOfRuleComposedSchema {\n  return 'anyOf' in schema;\n}\n\nexport function isAllOfRuleComposedSchema(schema: Schema): schema is AllOfRuleComposedSchema {\n  return 'allOf' in schema;\n}\n\nexport function isOneOfRuleComposedSchema(schema: Schema): schema is OneOfRuleComposedSchema {\n  return 'oneOf' in schema;\n}\n\nexport function isNotRuleComposedSchema(schema: Schema): schema is NotRuleComposedSchema {\n  return 'not' in schema;\n}\n\nexport function isComposedSchema(schema: Schema): schema is ComposedSchema {\n  return (\n    isAnyOfRuleComposedSchema(schema) ||\n    isAllOfRuleComposedSchema(schema) ||\n    isOneOfRuleComposedSchema(schema) ||\n    isNotRuleComposedSchema(schema)\n  );\n}\n\nexport function isNonComposedSchema(schema: Schema): schema is NonComposedSchema {\n  return !isComposedSchema(schema);\n}\n\nexport function isNonComposedRegularSchema(schema: Schema): schema is NonComposedRegularSchema {\n  return isNonComposedSchema(schema) && !isReferenceSchema(schema);\n}\n\nexport function isNullableSchema(schema: Schema): schema is NullableSchema {\n  return !isReferenceSchema(schema) && !!schema.nullable;\n}\n\nexport function decomposeSchema(schema: ComposedSchema): readonly Schema[] {\n  if (isAnyOfRuleComposedSchema(schema)) {\n    return schema.anyOf;\n  }\n\n  if (isAllOfRuleComposedSchema(schema)) {\n    return schema.allOf;\n  }\n\n  if (isOneOfRuleComposedSchema(schema)) {\n    return schema.oneOf;\n  }\n\n  return [schema.not];\n}\n\nexport function isArraySchema(schema: Schema): schema is ArraySchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'array';\n}\n\nexport function isBooleanSchema(schema: Schema): schema is BooleanSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'boolean';\n}\n\nexport function isIntegerSchema(schema: Schema): schema is IntegerSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'integer';\n}\n\nexport function isNumberSchema(schema: Schema): schema is NumberSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'number';\n}\n\nexport function isObjectSchema(schema: Schema): schema is ObjectSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'object';\n}\n\nexport function isStringSchema(schema: Schema): schema is StringSchema {\n  return isNonComposedRegularSchema(schema) && schema.type === 'string';\n}\n\nexport function isEnumSchema(schema: Schema): schema is EnumSchema {\n  return isStringSchema(schema) && !!schema.enum;\n}\n\nexport function isEmptyObject(schema: Schema): schema is EmptyObjectSchema {\n  return isObjectSchema(schema) && !schema.properties;\n}\n\nexport function isMapSchema(schema: Schema): schema is MapSchema {\n  return isEmptyObject(schema) && !!schema.additionalProperties;\n}\n\nexport function convertReferenceSchemaToSpecifier({ $ref }: ReferenceSchema): string {\n  return simplifyFullyQualifiedName($ref);\n}\n\nconst COMPONENTS_SCHEMAS_REF_LENGTH = '#/components/schemas/'.length;\n\nexport function convertReferenceSchemaToPath({ $ref }: ReferenceSchema): string {\n  return convertFullyQualifiedNameToRelativePath($ref.substring(COMPONENTS_SCHEMAS_REF_LENGTH));\n}\n\nexport function resolveReference(\n  schemas: ReadonlyDeep<OpenAPIV3.ComponentsObject>['schemas'],\n  { $ref }: ReferenceSchema,\n): Schema | undefined {\n  if (schemas) {\n    for (const [name, schema] of Object.entries(schemas)) {\n      if ($ref.includes(name)) {\n        return schema;\n      }\n    }\n  }\n\n  return undefined;\n}\n"],
  "mappings": "AAEA,SAAS,yCAAyC,kCAAkD;AAmC7F,SAAS,kBAAkB,QAA2C;AAC3E,SAAO,UAAU;AACnB;AAEO,SAAS,0BAA0B,QAAmD;AAC3F,SAAO,WAAW;AACpB;AAEO,SAAS,0BAA0B,QAAmD;AAC3F,SAAO,WAAW;AACpB;AAEO,SAAS,0BAA0B,QAAmD;AAC3F,SAAO,WAAW;AACpB;AAEO,SAAS,wBAAwB,QAAiD;AACvF,SAAO,SAAS;AAClB;AAEO,SAAS,iBAAiB,QAA0C;AACzE,SACE,0BAA0B,MAAM,KAChC,0BAA0B,MAAM,KAChC,0BAA0B,MAAM,KAChC,wBAAwB,MAAM;AAElC;AAEO,SAAS,oBAAoB,QAA6C;AAC/E,SAAO,CAAC,iBAAiB,MAAM;AACjC;AAEO,SAAS,2BAA2B,QAAoD;AAC7F,SAAO,oBAAoB,MAAM,KAAK,CAAC,kBAAkB,MAAM;AACjE;AAEO,SAAS,iBAAiB,QAA0C;AACzE,SAAO,CAAC,kBAAkB,MAAM,KAAK,CAAC,CAAC,OAAO;AAChD;AAEO,SAAS,gBAAgB,QAA2C;AACzE,MAAI,0BAA0B,MAAM,GAAG;AACrC,WAAO,OAAO;AAAA,EAChB;AAEA,MAAI,0BAA0B,MAAM,GAAG;AACrC,WAAO,OAAO;AAAA,EAChB;AAEA,MAAI,0BAA0B,MAAM,GAAG;AACrC,WAAO,OAAO;AAAA,EAChB;AAEA,SAAO,CAAC,OAAO,GAAG;AACpB;AAEO,SAAS,cAAc,QAAuC;AACnE,SAAO,2BAA2B,MAAM,KAAK,OAAO,SAAS;AAC/D;AAEO,SAAS,gBAAgB,QAAyC;AACvE,SAAO,2BAA2B,MAAM,KAAK,OAAO,SAAS;AAC/D;AAEO,SAAS,gBAAgB,QAAyC;AACvE,SAAO,2BAA2B,MAAM,KAAK,OAAO,SAAS;AAC/D;AAEO,SAAS,eAAe,QAAwC;AACrE,SAAO,2BAA2B,MAAM,KAAK,OAAO,SAAS;AAC/D;AAEO,SAAS,eAAe,QAAwC;AACrE,SAAO,2BAA2B,MAAM,KAAK,OAAO,SAAS;AAC/D;AAEO,SAAS,eAAe,QAAwC;AACrE,SAAO,2BAA2B,MAAM,KAAK,OAAO,SAAS;AAC/D;AAEO,SAAS,aAAa,QAAsC;AACjE,SAAO,eAAe,MAAM,KAAK,CAAC,CAAC,OAAO;AAC5C;AAEO,SAAS,cAAc,QAA6C;AACzE,SAAO,eAAe,MAAM,KAAK,CAAC,OAAO;AAC3C;AAEO,SAAS,YAAY,QAAqC;AAC/D,SAAO,cAAc,MAAM,KAAK,CAAC,CAAC,OAAO;AAC3C;AAEO,SAAS,kCAAkC,EAAE,KAAK,GAA4B;AACnF,SAAO,2BAA2B,IAAI;AACxC;AAEA,MAAM,gCAAgC,wBAAwB;AAEvD,SAAS,6BAA6B,EAAE,KAAK,GAA4B;AAC9E,SAAO,wCAAwC,KAAK,UAAU,6BAA6B,CAAC;AAC9F;AAEO,SAAS,iBACd,SACA,EAAE,KAAK,GACa;AACpB,MAAI,SAAS;AACX,eAAW,CAAC,MAAM,MAAM,KAAK,OAAO,QAAQ,OAAO,GAAG;AACpD,UAAI,KAAK,SAAS,IAAI,GAAG;AACvB,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": []
}
