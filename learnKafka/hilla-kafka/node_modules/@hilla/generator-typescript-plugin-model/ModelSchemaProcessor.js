import {
  convertReferenceSchemaToPath,
  convertReferenceSchemaToSpecifier,
  decomposeSchema,
  isArraySchema,
  isBooleanSchema,
  isComposedSchema,
  isIntegerSchema,
  isMapSchema,
  isNullableSchema,
  isNumberSchema,
  isReferenceSchema,
  isStringSchema
} from "@hilla/generator-typescript-core/Schema.js";
import ts, {
} from "typescript";
import { MetadataProcessor } from "./MetadataProcessor.js";
import { createModelBuildingCallback, importBuiltInFormModel } from "./utils.js";
import { hasValidationConstraints, ValidationConstraintProcessor } from "./ValidationConstraintProcessor.js";
const $dependencies = Symbol();
const $processArray = Symbol();
const $processRecord = Symbol();
const $processReference = Symbol();
const $processString = Symbol();
const $processNumber = Symbol();
const $processBoolean = Symbol();
const $processUnknown = Symbol();
const $originalSchema = Symbol();
const $schema = Symbol();
class ModelSchemaPartProcessor {
  [$dependencies];
  [$originalSchema];
  [$schema];
  constructor(schema, dependencies) {
    this[$dependencies] = dependencies;
    this[$originalSchema] = schema;
    this[$schema] = isComposedSchema(schema) ? decomposeSchema(schema)[0] : schema;
  }
  process() {
    const schema = this[$schema];
    if (isReferenceSchema(schema)) {
      return this[$processReference](schema);
    }
    if (isArraySchema(schema)) {
      return this[$processArray](schema);
    }
    if (isMapSchema(schema)) {
      return this[$processRecord](schema);
    }
    if (isStringSchema(schema)) {
      return this[$processString](schema);
    }
    if (isNumberSchema(schema) || isIntegerSchema(schema)) {
      return this[$processNumber](schema);
    }
    if (isBooleanSchema(schema)) {
      return this[$processBoolean](schema);
    }
    return this[$processUnknown](schema);
  }
}
function handleNullableInternalType(schema, typeNode) {
  return isNullableSchema(schema) ? ts.factory.createUnionTypeNode([typeNode, ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword)]) : typeNode;
}
class ModelSchemaInternalTypeProcessor extends ModelSchemaPartProcessor {
  [$processArray](schema) {
    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("ReadonlyArray"), [
      handleNullableInternalType(
        schema.items,
        new ModelSchemaInternalTypeProcessor(schema.items, this[$dependencies]).process()
      )
    ]);
  }
  [$processBoolean](_) {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
  }
  [$processNumber](_) {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
  }
  [$processRecord]({ additionalProperties: props }) {
    const valueType = typeof props === "boolean" ? ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword) : handleNullableInternalType(props, new ModelSchemaInternalTypeProcessor(props, this[$dependencies]).process());
    return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("Record"), [
      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
      valueType
    ]);
  }
  [$processReference](schema) {
    const { imports, paths } = this[$dependencies];
    const typeName = convertReferenceSchemaToSpecifier(schema);
    const typePath = paths.createRelativePath(convertReferenceSchemaToPath(schema));
    return ts.factory.createTypeReferenceNode(
      imports.default.getIdentifier(typePath) ?? imports.default.add(typePath, typeName, true)
    );
  }
  [$processString](_) {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
  }
  [$processUnknown](_) {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
  }
}
class ModelSchemaIdentifierProcessor extends ModelSchemaPartProcessor {
  [$processArray](_) {
    return importBuiltInFormModel("ArrayModel", this[$dependencies]);
  }
  [$processBoolean](_) {
    return importBuiltInFormModel("BooleanModel", this[$dependencies]);
  }
  [$processNumber](_) {
    return importBuiltInFormModel("NumberModel", this[$dependencies]);
  }
  [$processRecord](_) {
    return importBuiltInFormModel("ObjectModel", this[$dependencies]);
  }
  [$processReference](schema) {
    const { imports, paths } = this[$dependencies];
    const name = `${convertReferenceSchemaToSpecifier(schema)}Model`;
    const path = paths.createRelativePath(`${convertReferenceSchemaToPath(schema)}Model`);
    return imports.default.getIdentifier(path) ?? imports.default.add(path, name);
  }
  [$processString](_) {
    return importBuiltInFormModel("StringModel", this[$dependencies]);
  }
  [$processUnknown](_) {
    return importBuiltInFormModel("ObjectModel", this[$dependencies]);
  }
}
class ModelSchemaTypeProcessor extends ModelSchemaPartProcessor {
  #id;
  constructor(schema, dependencies) {
    super(schema, dependencies);
    this.#id = new ModelSchemaIdentifierProcessor(schema, dependencies);
  }
  [$processArray](schema) {
    return ts.factory.createTypeReferenceNode(this.#id[$processArray](schema), [
      new ModelSchemaTypeProcessor(schema.items, this[$dependencies]).process()
    ]);
  }
  [$processBoolean](schema) {
    return ts.factory.createTypeReferenceNode(this.#id[$processBoolean](schema));
  }
  [$processNumber](schema) {
    return ts.factory.createTypeReferenceNode(this.#id[$processNumber](schema));
  }
  [$processRecord](schema) {
    return ts.factory.createTypeReferenceNode(this.#id[$processRecord](schema), [
      new ModelSchemaInternalTypeProcessor(schema, this[$dependencies]).process()
    ]);
  }
  [$processReference](schema) {
    return ts.factory.createTypeReferenceNode(this.#id[$processReference](schema));
  }
  [$processString](schema) {
    return ts.factory.createTypeReferenceNode(this.#id[$processString](schema));
  }
  [$processUnknown](schema) {
    return ts.factory.createTypeReferenceNode(this.#id[$processUnknown](schema));
  }
}
class ModelSchemaExpressionProcessor extends ModelSchemaPartProcessor {
  #validationConstraintProcessor;
  #metadataProcessor;
  constructor(schema, dependencies) {
    super(schema, dependencies);
    this.#validationConstraintProcessor = new ValidationConstraintProcessor(
      (name) => importBuiltInFormModel(name, dependencies)
    );
    this.#metadataProcessor = new MetadataProcessor();
  }
  process() {
    const originalSchema = this[$originalSchema];
    let result = super.process();
    const modelOptionsProperties = [
      this.#createValidatorsProperty(originalSchema),
      this.#createMetadataProperty(originalSchema)
    ].filter(Boolean);
    if (modelOptionsProperties.length > 0) {
      const optionsObject = ts.factory.createObjectLiteralExpression(modelOptionsProperties);
      result = [...result, optionsObject];
    }
    return [isNullableSchema(originalSchema) ? ts.factory.createTrue() : ts.factory.createFalse(), ...result];
  }
  [$processArray](schema) {
    const model = new ModelSchemaIdentifierProcessor(schema.items, this[$dependencies]).process();
    return [
      createModelBuildingCallback(
        model,
        new ModelSchemaExpressionProcessor(schema.items, this[$dependencies]).process()
      )
    ];
  }
  [$processBoolean](_) {
    return [];
  }
  [$processNumber](_) {
    return [];
  }
  [$processRecord](_) {
    return [];
  }
  [$processReference](_) {
    return [];
  }
  [$processString](_) {
    return [];
  }
  [$processUnknown](_) {
    return [];
  }
  #createValidatorsProperty(schema) {
    if (!hasValidationConstraints(schema)) {
      return null;
    }
    const constraints = schema["x-validation-constraints"].map(
      (constraint) => this.#validationConstraintProcessor.process(constraint)
    );
    return ts.factory.createPropertyAssignment("validators", ts.factory.createArrayLiteralExpression(constraints));
  }
  #createMetadataProperty(schema) {
    const metadata = this.#metadataProcessor.process(schema);
    return metadata ? ts.factory.createPropertyAssignment("meta", metadata) : null;
  }
}
export {
  ModelSchemaExpressionProcessor,
  ModelSchemaPartProcessor,
  ModelSchemaTypeProcessor
};
//# sourceMappingURL=ModelSchemaProcessor.js.map
