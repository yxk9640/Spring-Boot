import { dirname } from "path/posix";
import {
  convertReferenceSchemaToPath,
  convertReferenceSchemaToSpecifier,
  decomposeSchema,
  isComposedSchema,
  isEmptyObject,
  isEnumSchema,
  isObjectSchema,
  isReferenceSchema
} from "@hilla/generator-typescript-core/Schema.js";
import {
  convertFullyQualifiedNameToRelativePath,
  simplifyFullyQualifiedName
} from "@hilla/generator-typescript-core/utils.js";
import createSourceFile from "@hilla/generator-typescript-utils/createSourceFile.js";
import DependencyManager from "@hilla/generator-typescript-utils/dependencies/DependencyManager.js";
import PathManager from "@hilla/generator-typescript-utils/dependencies/PathManager.js";
import ts, {
} from "typescript";
import { ModelSchemaExpressionProcessor, ModelSchemaTypeProcessor } from "./ModelSchemaProcessor.js";
import { importBuiltInFormModel, createModelBuildingCallback, createEmptyValueMaker } from "./utils.js";
const $dependencies = Symbol();
const $entity = Symbol();
const $fullyQualifiedName = Symbol();
const $model = Symbol();
const $processDeclaration = Symbol();
class EntityModelProcessor {
  static process(name, component, context) {
    context.owner.logger.debug(`Processing model for entity: ${name}`);
    const schema = isComposedSchema(component) ? decomposeSchema(component)[0] : component;
    return isEnumSchema(schema) ? (
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new EntityEnumModelProcessor(name).process()
    ) : (
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new EntityClassModelProcessor(name, component, context).process()
    );
  }
  [$dependencies];
  [$entity];
  [$fullyQualifiedName];
  [$model];
  #outputPathManager = new PathManager({ extension: "ts" });
  constructor(name, shouldImportEntityAsType) {
    this[$fullyQualifiedName] = name;
    const entityName = simplifyFullyQualifiedName(name);
    const entityPath = convertFullyQualifiedNameToRelativePath(name);
    const modelName = `${entityName}Model`;
    const modelPath = `${entityPath}Model`;
    this[$dependencies] = new DependencyManager(new PathManager({ extension: ".js", relativeTo: dirname(modelPath) }));
    const { exports, imports, paths } = this[$dependencies];
    this[$model] = {
      id: exports.default.set(modelName),
      path: modelPath
    };
    this[$entity] = {
      id: imports.default.add(paths.createRelativePath(entityPath), entityName, shouldImportEntityAsType),
      path: entityPath
    };
  }
  process() {
    const declaration = this[$processDeclaration]();
    const { exports, imports } = this[$dependencies];
    const importStatements = imports.toCode();
    const exportStatement = exports.toCode();
    return createSourceFile(
      [...importStatements, declaration, ...exportStatement].filter(Boolean),
      this.#outputPathManager.createRelativePath(this[$model].path)
    );
  }
}
class EntityClassModelProcessor extends EntityModelProcessor {
  #component;
  #context;
  #fullyQualifiedName;
  #getPropertyModelSymbol;
  #makeObjectEmptyValueCreator;
  constructor(name, component, context) {
    super(name, true);
    this.#component = component;
    this.#context = context;
    this.#fullyQualifiedName = name;
    this.#getPropertyModelSymbol = this[$dependencies].imports.named.add("@hilla/form", "_getPropertyModel");
    this.#makeObjectEmptyValueCreator = this[$dependencies].imports.named.add(
      "@hilla/form",
      "makeObjectEmptyValueCreator"
    );
  }
  [$processDeclaration]() {
    const { logger } = this.#context.owner;
    let entitySchema = this.#component;
    let parent;
    if (isComposedSchema(this.#component)) {
      const decomposed = decomposeSchema(this.#component);
      if (decomposed.length > 2) {
        logger.debug(
          this.#component,
          `The schema for a class component ${this.#fullyQualifiedName} has more than two components. This plugin will ignore it.`
        );
        return void 0;
      }
      const [parentSchema, childSchema] = decomposed;
      if (!isReferenceSchema(parentSchema)) {
        logger.debug(parentSchema, "Only reference schema allowed for parent class");
        return void 0;
      }
      entitySchema = childSchema;
      parent = this.#processParentClass(parentSchema);
    } else {
      parent = importBuiltInFormModel("ObjectModel", this[$dependencies]);
    }
    return this.#processModelClass(entitySchema, this[$entity].id, parent);
  }
  #processClassElements({ properties }) {
    if (!properties) {
      return [];
    }
    return Object.entries(properties).map(([name, schema]) => {
      const type = new ModelSchemaTypeProcessor(schema, this[$dependencies]).process();
      const args = new ModelSchemaExpressionProcessor(schema, this[$dependencies]).process();
      return ts.factory.createGetAccessorDeclaration(
        void 0,
        ts.factory.createIdentifier(name),
        [],
        type,
        ts.factory.createBlock(
          [
            ts.factory.createReturnStatement(
              ts.factory.createCallExpression(
                ts.factory.createElementAccessExpression(ts.factory.createThis(), this.#getPropertyModelSymbol),
                void 0,
                [ts.factory.createStringLiteral(name), createModelBuildingCallback(type.typeName, args)]
              )
            )
          ],
          true
        )
      );
    });
  }
  #processModelClass(schema, entity, parent) {
    const { logger } = this.#context.owner;
    if (!isObjectSchema(schema)) {
      logger.debug(schema, `Component is not an object: ${this.#fullyQualifiedName}`);
      return void 0;
    }
    if (isEmptyObject(schema)) {
      logger.warn(`Component has no properties: ${this.#fullyQualifiedName}`);
    }
    const typeT = ts.factory.createIdentifier("T");
    const modelTypeParameters = ts.factory.createTypeParameterDeclaration(
      void 0,
      typeT,
      ts.factory.createTypeReferenceNode(entity),
      ts.factory.createTypeReferenceNode(entity)
    );
    return ts.factory.createClassDeclaration(
      void 0,
      this[$model].id,
      [modelTypeParameters],
      [
        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
          ts.factory.createExpressionWithTypeArguments(parent, [ts.factory.createTypeReferenceNode(typeT)])
        ])
      ],
      [
        createEmptyValueMaker(this.#makeObjectEmptyValueCreator, this[$model].id),
        ...this.#processClassElements(schema)
      ]
    );
  }
  #processParentClass(schema) {
    const { imports, paths } = this[$dependencies];
    const specifier = convertReferenceSchemaToSpecifier(schema);
    const path = convertReferenceSchemaToPath(schema);
    const modelPath = paths.createRelativePath(`${path}Model`);
    const modelSpecifier = `${specifier}Model`;
    return imports.default.add(modelPath, modelSpecifier, false);
  }
}
class EntityEnumModelProcessor extends EntityModelProcessor {
  constructor(name) {
    super(name, false);
  }
  [$processDeclaration]() {
    const enumModel = importBuiltInFormModel("EnumModel", this[$dependencies]);
    const enumPropertySymbol = this[$dependencies].imports.named.add("@hilla/form", "_enum");
    const makeEnumEmptyValueCreator = this[$dependencies].imports.named.add("@hilla/form", "makeEnumEmptyValueCreator");
    return ts.factory.createClassDeclaration(
      void 0,
      this[$model].id,
      void 0,
      [
        ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
          ts.factory.createExpressionWithTypeArguments(enumModel, [
            ts.factory.createTypeQueryNode(this[$entity].id, void 0)
          ])
        ])
      ],
      [
        createEmptyValueMaker(makeEnumEmptyValueCreator, this[$model].id),
        ts.factory.createPropertyDeclaration(
          [ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword)],
          ts.factory.createComputedPropertyName(enumPropertySymbol),
          void 0,
          void 0,
          this[$entity].id
        )
      ]
    );
  }
}
export {
  EntityClassModelProcessor,
  EntityEnumModelProcessor,
  EntityModelProcessor
};
//# sourceMappingURL=EntityModelProcessor.js.map
