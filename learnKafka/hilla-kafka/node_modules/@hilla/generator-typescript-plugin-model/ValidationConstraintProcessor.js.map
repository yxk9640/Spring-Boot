{
  "version": 3,
  "sources": ["src/ValidationConstraintProcessor.ts"],
  "sourcesContent": ["import {\n  isNonComposedRegularSchema,\n  type NonComposedRegularSchema,\n  type Schema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport { template, transform } from '@hilla/generator-typescript-utils/ast.js';\nimport ts, {\n  type Expression,\n  type Identifier,\n  type NewExpression,\n  type Statement,\n  type VariableStatement,\n} from 'typescript';\n\nexport type ValidationConstrainedSchema = NonComposedRegularSchema &\n  Readonly<{ 'x-validation-constraints': readonly ValidationConstraint[] }>;\n\nexport function hasValidationConstraints(schema: Schema): schema is ValidationConstrainedSchema {\n  return (\n    isNonComposedRegularSchema(schema) &&\n    'x-validation-constraints' in schema &&\n    (schema as ValidationConstrainedSchema)['x-validation-constraints'].length > 0\n  );\n}\n\nexport interface ValidationConstraint {\n  simpleName: string;\n  attributes?: Record<string, unknown>;\n}\n\nexport type ValidationConstraintImporter = (name: string) => Identifier;\n\nfunction selector<T extends Expression>([statement]: readonly Statement[]): T {\n  return (statement as VariableStatement).declarationList.declarations[0].initializer as T;\n}\n\nconst variableStatementVar = 'const a';\n\nexport class ValidationConstraintProcessor {\n  readonly #importer: ValidationConstraintImporter;\n\n  constructor(importer: ValidationConstraintImporter) {\n    this.#importer = importer;\n  }\n\n  process(constraint: ValidationConstraint): NewExpression {\n    return ts.factory.createNewExpression(\n      this.#importer(constraint.simpleName),\n      undefined,\n      constraint.attributes ? [this.#processAttributes(constraint.attributes)] : [],\n    );\n  }\n\n  #processAttributes(attributes: Record<string, unknown>): Expression {\n    const names = Object.keys(attributes);\n    const tpl = JSON.stringify(names.includes('value') && names.length === 1 ? attributes.value : attributes);\n\n    return template(`${variableStatementVar}=${tpl}`, selector, [\n      transform((node) =>\n        ts.isPropertyAssignment(node) && ts.isStringLiteral(node.name)\n          ? ts.factory.createPropertyAssignment(node.name.text, node.initializer)\n          : node,\n      ),\n    ]);\n  }\n}\n"],
  "mappings": "AAAA;AAAA,EACE;AAAA,OAGK;AACP,SAAS,UAAU,iBAAiB;AACpC,OAAO;AAAA,OAMA;AAKA,SAAS,yBAAyB,QAAuD;AAC9F,SACE,2BAA2B,MAAM,KACjC,8BAA8B,UAC7B,OAAuC,0BAA0B,EAAE,SAAS;AAEjF;AASA,SAAS,SAA+B,CAAC,SAAS,GAA4B;AAC5E,SAAQ,UAAgC,gBAAgB,aAAa,CAAC,EAAE;AAC1E;AAEA,MAAM,uBAAuB;AAEtB,MAAM,8BAA8B;AAAA,EAChC;AAAA,EAET,YAAY,UAAwC;AAClD,SAAK,YAAY;AAAA,EACnB;AAAA,EAEA,QAAQ,YAAiD;AACvD,WAAO,GAAG,QAAQ;AAAA,MAChB,KAAK,UAAU,WAAW,UAAU;AAAA,MACpC;AAAA,MACA,WAAW,aAAa,CAAC,KAAK,mBAAmB,WAAW,UAAU,CAAC,IAAI,CAAC;AAAA,IAC9E;AAAA,EACF;AAAA,EAEA,mBAAmB,YAAiD;AAClE,UAAM,QAAQ,OAAO,KAAK,UAAU;AACpC,UAAM,MAAM,KAAK,UAAU,MAAM,SAAS,OAAO,KAAK,MAAM,WAAW,IAAI,WAAW,QAAQ,UAAU;AAExG,WAAO,SAAS,GAAG,oBAAoB,IAAI,GAAG,IAAI,UAAU;AAAA,MAC1D;AAAA,QAAU,CAAC,SACT,GAAG,qBAAqB,IAAI,KAAK,GAAG,gBAAgB,KAAK,IAAI,IACzD,GAAG,QAAQ,yBAAyB,KAAK,KAAK,MAAM,KAAK,WAAW,IACpE;AAAA,MACN;AAAA,IACF,CAAC;AAAA,EACH;AACF;",
  "names": []
}
