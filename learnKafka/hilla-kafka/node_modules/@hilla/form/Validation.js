import { getBinderNode } from "./BinderNode.js";
import { NumberModel } from "./Models.js";
import { Required } from "./Validators.js";
class ValidationError extends Error {
  errors;
  constructor(errors) {
    super(
      [
        "There are validation errors in the form.",
        ...errors.map(
          (e) => `${e.property.toString()} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ""}`
        )
      ].join("\n - ")
    );
    this.errors = errors;
    this.name = this.constructor.name;
  }
}
class ServerValidator {
  name = "ServerValidator";
  message;
  constructor(message) {
    this.message = message;
  }
  validate = () => false;
}
function setPropertyAbsolutePath(binderNodeName, result) {
  if (typeof result.property === "string" && binderNodeName.length > 0) {
    result.property = `${binderNodeName}.${result.property}`;
  }
  return result;
}
async function runValidator(model, validator, interpolateMessageCallback) {
  const binderNode = getBinderNode(model);
  const value = binderNode.value;
  const interpolateMessage = (message) => {
    if (!interpolateMessageCallback) {
      return message;
    }
    return interpolateMessageCallback(message, validator, binderNode);
  };
  if (!binderNode.required && !new Required().validate(value) && !(model instanceof NumberModel)) {
    return [];
  }
  try {
    const result = await validator.validate(value, binderNode.binder);
    if (result === false) {
      return [{ message: interpolateMessage(validator.message), property: binderNode.name, validator, value }];
    }
    if (result === true || Array.isArray(result) && result.length === 0) {
      return [];
    }
    if (Array.isArray(result)) {
      return result.map((result2) => ({
        message: interpolateMessage(validator.message),
        ...setPropertyAbsolutePath(binderNode.name, result2),
        validator,
        value
      }));
    }
    return [
      {
        message: interpolateMessage(validator.message),
        ...setPropertyAbsolutePath(binderNode.name, result),
        validator,
        value
      }
    ];
  } catch (error) {
    console.error(`${binderNode.name} - Validator ${validator.constructor.name} threw an error:`, error);
    return [{ message: "Validator threw an error", property: binderNode.name, validator, value }];
  }
}
export {
  ServerValidator,
  ValidationError,
  runValidator
};
//# sourceMappingURL=Validation.js.map
