{
  "version": 3,
  "sources": ["src/Validation.ts"],
  "sourcesContent": ["import type { BinderNode } from './BinderNode.js';\nimport { getBinderNode } from './BinderNode.js';\nimport type { BinderRoot } from './BinderRoot.js';\nimport { type AbstractModel, NumberModel, type Value } from './Models.js';\nimport { Required } from './Validators.js';\n\nexport interface ValueError<T = unknown> {\n  property: AbstractModel | string;\n  message: string;\n  value: T;\n  validator: Validator<T>;\n}\n\nexport interface ValidationResult {\n  property: AbstractModel | string;\n  message?: string;\n}\n\nexport class ValidationError extends Error {\n  errors: readonly ValueError[];\n\n  constructor(errors: readonly ValueError[]) {\n    super(\n      [\n        'There are validation errors in the form.',\n        ...errors.map(\n          (e) => `${e.property.toString()} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ''}`,\n        ),\n      ].join('\\n - '),\n    );\n    this.errors = errors;\n    this.name = this.constructor.name;\n  }\n}\n\nexport type InterpolateMessageCallback<M extends AbstractModel> = (\n  message: string,\n  validator: Validator<Value<M>>,\n  binderNode: BinderNode<M>,\n) => string;\n\nexport interface Validator<T = unknown> {\n  message: string;\n  impliesRequired?: boolean;\n  name?: string;\n  validate(\n    value: T,\n    binder: BinderRoot,\n  ):\n    | Promise<ValidationResult | boolean | readonly ValidationResult[]>\n    | ValidationResult\n    | boolean\n    | readonly ValidationResult[];\n}\n\nexport class ServerValidator implements Validator {\n  name = 'ServerValidator';\n  message: string;\n\n  constructor(message: string) {\n    this.message = message;\n  }\n\n  validate = (): boolean => false;\n}\n\n// The `property` field of `ValidationResult`s is a path relative to the parent.\nfunction setPropertyAbsolutePath(binderNodeName: string, result: ValidationResult): ValidationResult {\n  if (typeof result.property === 'string' && binderNodeName.length > 0) {\n    result.property = `${binderNodeName}.${result.property}`;\n  }\n  return result;\n}\n\nexport async function runValidator<M extends AbstractModel>(\n  model: M,\n  validator: Validator<Value<M>>,\n  interpolateMessageCallback?: InterpolateMessageCallback<M>,\n): Promise<ReadonlyArray<ValueError<Value<M>>>> {\n  const binderNode = getBinderNode(model);\n  const value = binderNode.value as Value<M>;\n\n  const interpolateMessage = (message: string) => {\n    if (!interpolateMessageCallback) {\n      return message;\n    }\n    return interpolateMessageCallback(message, validator, binderNode);\n  };\n\n  // If model is not required and value empty, do not run any validator. Except\n  // always validate NumberModel, which has a mandatory builtin validator\n  // to indicate NaN input.\n  if (!binderNode.required && !new Required().validate(value) && !(model instanceof NumberModel)) {\n    return [];\n  }\n\n  try {\n    const result = await validator.validate(value, binderNode.binder);\n\n    if (result === false) {\n      return [{ message: interpolateMessage(validator.message), property: binderNode.name, validator, value }];\n    }\n\n    if (result === true || (Array.isArray(result) && result.length === 0)) {\n      return [];\n    }\n\n    if (Array.isArray(result)) {\n      return result.map((result2) => ({\n        message: interpolateMessage(validator.message),\n        ...setPropertyAbsolutePath(binderNode.name, result2),\n        validator,\n        value,\n      }));\n    }\n\n    return [\n      {\n        message: interpolateMessage(validator.message),\n        ...setPropertyAbsolutePath(binderNode.name, result as ValidationResult),\n        validator,\n        value,\n      },\n    ];\n  } catch (error: unknown) {\n    console.error(`${binderNode.name} - Validator ${validator.constructor.name} threw an error:`, error);\n    return [{ message: 'Validator threw an error', property: binderNode.name, validator, value }];\n  }\n}\n"],
  "mappings": "AACA,SAAS,qBAAqB;AAE9B,SAA6B,mBAA+B;AAC5D,SAAS,gBAAgB;AAclB,MAAM,wBAAwB,MAAM;AAAA,EACzC;AAAA,EAEA,YAAY,QAA+B;AACzC;AAAA,MACE;AAAA,QACE;AAAA,QACA,GAAG,OAAO;AAAA,UACR,CAAC,MAAM,GAAG,EAAE,SAAS,SAAS,CAAC,MAAM,EAAE,UAAU,YAAY,IAAI,GAAG,EAAE,UAAU,KAAK,EAAE,OAAO,KAAK,EAAE;AAAA,QACvG;AAAA,MACF,EAAE,KAAK,OAAO;AAAA,IAChB;AACA,SAAK,SAAS;AACd,SAAK,OAAO,KAAK,YAAY;AAAA,EAC/B;AACF;AAsBO,MAAM,gBAAqC;AAAA,EAChD,OAAO;AAAA,EACP;AAAA,EAEA,YAAY,SAAiB;AAC3B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,WAAW,MAAe;AAC5B;AAGA,SAAS,wBAAwB,gBAAwB,QAA4C;AACnG,MAAI,OAAO,OAAO,aAAa,YAAY,eAAe,SAAS,GAAG;AACpE,WAAO,WAAW,GAAG,cAAc,IAAI,OAAO,QAAQ;AAAA,EACxD;AACA,SAAO;AACT;AAEA,eAAsB,aACpB,OACA,WACA,4BAC8C;AAC9C,QAAM,aAAa,cAAc,KAAK;AACtC,QAAM,QAAQ,WAAW;AAEzB,QAAM,qBAAqB,CAAC,YAAoB;AAC9C,QAAI,CAAC,4BAA4B;AAC/B,aAAO;AAAA,IACT;AACA,WAAO,2BAA2B,SAAS,WAAW,UAAU;AAAA,EAClE;AAKA,MAAI,CAAC,WAAW,YAAY,CAAC,IAAI,SAAS,EAAE,SAAS,KAAK,KAAK,EAAE,iBAAiB,cAAc;AAC9F,WAAO,CAAC;AAAA,EACV;AAEA,MAAI;AACF,UAAM,SAAS,MAAM,UAAU,SAAS,OAAO,WAAW,MAAM;AAEhE,QAAI,WAAW,OAAO;AACpB,aAAO,CAAC,EAAE,SAAS,mBAAmB,UAAU,OAAO,GAAG,UAAU,WAAW,MAAM,WAAW,MAAM,CAAC;AAAA,IACzG;AAEA,QAAI,WAAW,QAAS,MAAM,QAAQ,MAAM,KAAK,OAAO,WAAW,GAAI;AACrE,aAAO,CAAC;AAAA,IACV;AAEA,QAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,aAAO,OAAO,IAAI,CAAC,aAAa;AAAA,QAC9B,SAAS,mBAAmB,UAAU,OAAO;AAAA,QAC7C,GAAG,wBAAwB,WAAW,MAAM,OAAO;AAAA,QACnD;AAAA,QACA;AAAA,MACF,EAAE;AAAA,IACJ;AAEA,WAAO;AAAA,MACL;AAAA,QACE,SAAS,mBAAmB,UAAU,OAAO;AAAA,QAC7C,GAAG,wBAAwB,WAAW,MAAM,MAA0B;AAAA,QACtE;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,SAAS,OAAgB;AACvB,YAAQ,MAAM,GAAG,WAAW,IAAI,gBAAgB,UAAU,YAAY,IAAI,oBAAoB,KAAK;AACnG,WAAO,CAAC,EAAE,SAAS,4BAA4B,UAAU,WAAW,MAAM,WAAW,MAAM,CAAC;AAAA,EAC9F;AACF;",
  "names": []
}
