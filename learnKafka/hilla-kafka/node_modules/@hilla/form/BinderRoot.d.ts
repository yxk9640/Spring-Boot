import { _update, BinderNode } from './BinderNode.js';
import { type FieldStrategy } from './Field.js';
import { type AbstractModel, type DetachedModelConstructor, type Value } from './Models.js';
import type { ClassStaticProperties } from './types.js';
import { type InterpolateMessageCallback, type Validator, type ValueError } from './Validation.js';
export type BinderConfiguration<T> = Readonly<{
    onChange?(oldValue?: T): void;
    onSubmit?(value: T): Promise<T | undefined | void>;
}>;
export type BinderRootConfiguration<T> = BinderConfiguration<T> & Readonly<{
    context?: unknown;
}>;
/**
 * A simplified Binder that does not require a context.
 * It can be used as root when there is no Element to use as context.
 *
 * @typeParam T - Type of the value that binds to a form
 * @typeParam M - Type of the model that describes the structure of the value
 */
export declare class BinderRoot<M extends AbstractModel = AbstractModel> extends BinderNode<M> {
    #private;
    static interpolateMessageCallback?: InterpolateMessageCallback<any>;
    readonly ['constructor']: ClassStaticProperties<typeof BinderRoot<M>>;
    /**
     *
     * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model
     * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.
     *
     * ```
     * binder = new BinderRoot(OrderModel);
     * or
     * binder = new BinderRoot(OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});
     * ```
     */
    constructor(Model: DetachedModelConstructor<M>, config?: BinderRootConfiguration<Value<M>>);
    /**
     * The initial value of the form, before any fields are edited by the user.
     */
    get defaultValue(): Value<M>;
    set defaultValue(newValue: Value<M>);
    get binder(): BinderRoot;
    /**
     * The current value of the form.
     */
    get value(): Value<M>;
    set value(newValue: Value<M>);
    /**
     * Indicates the submitting status of the form.
     * True if the form was submitted, but the submit promise is not resolved yet.
     */
    get submitting(): boolean;
    /**
     * Indicates the validating status of the form.
     * True when there is an ongoing validation.
     */
    get validating(): boolean;
    /**
     * Read the given value into the form and clear validation errors. Clears the form if the value is undefined.
     *
     * @param value - The value to read, or undefined to clear.
     */
    read(value: Value<M> | null | undefined): void;
    /**
     * Reset the form to the previous value
     */
    reset(): void;
    /**
     * Sets the form to empty value, as defined in the Model.
     */
    clear(): void;
    /**
     * Submit the current form value to a predefined
     * onSubmit callback.
     *
     * It's a no-op if the onSubmit callback is undefined.
     */
    submit(): Promise<Value<M> | undefined | void>;
    /**
     * Submit the current form value to callback
     *
     * @param endpointMethod - the callback function
     */
    submitTo<V>(endpointMethod: (value: Value<M>) => Promise<V>): Promise<V>;
    requestValidation<NM extends AbstractModel>(model: NM, validator: Validator<Value<NM>>): Promise<ReadonlyArray<ValueError<Value<NM>>>>;
    /**
     * Determines and returns the field directive strategy for the bound element.
     * Override to customise the binding strategy for a component.
     * The Binder extends BinderNode, see the inherited properties and methods below.
     *
     * @param elm - the bound element
     * @param model - the bound model
     */
    getFieldStrategy<TField>(elm: HTMLElement, model?: AbstractModel<TField>): FieldStrategy;
    protected performValidation(): Promise<void> | void;
    protected completeValidation(): void;
    protected [_update](oldValue: Value<M>): void;
}
//# sourceMappingURL=BinderRoot.d.ts.map