import isNumeric from "validator/es/lib/isNumeric.js";
import { getBinderNode } from "./BinderNode.js";
import { IsNumber } from "./Validators.js";
const _createEmptyItemValue = Symbol("itemModel");
const _parent = Symbol("parent");
const _key = Symbol("key");
const _fromString = Symbol("fromString");
const _validators = Symbol("validators");
const _meta = Symbol("meta");
const _getPropertyModel = Symbol("getPropertyModel");
const _enum = Symbol("enum");
const _optional = Symbol("optional");
function hasFromString(model) {
  return _fromString in model;
}
const modelDetachedParent = { $value$: void 0 };
function createDetachedModel(type) {
  return new type(modelDetachedParent, "$value$", false);
}
class AbstractModel {
  static createEmptyValue() {
    return void 0;
  }
  [_parent];
  [_validators];
  [_meta];
  [_optional];
  [_key];
  constructor(parent, key, optional, options) {
    this[_parent] = parent;
    this[_key] = key;
    this[_optional] = optional;
    this[_validators] = options?.validators ?? [];
    this[_meta] = options?.meta ?? {};
  }
  toString() {
    return String(this.valueOf());
  }
  valueOf() {
    const { value } = getBinderNode(this);
    if (value === void 0) {
      throw new TypeError("Value is undefined");
    }
    return value;
  }
}
class PrimitiveModel extends AbstractModel {
}
class BooleanModel extends PrimitiveModel {
  static createEmptyValue = Boolean;
  [_fromString](str) {
    return ["true", "1", "yes"].includes(str.toLowerCase());
  }
}
class NumberModel extends PrimitiveModel {
  static createEmptyValue = Number;
  constructor(parent, key, optional, options) {
    const validators = [new IsNumber(optional), ...options?.validators ?? []];
    super(parent, key, optional, { ...options, validators });
  }
  [_fromString](str) {
    if (str === "")
      return void 0;
    return isNumeric(str) ? Number.parseFloat(str) : NaN;
  }
}
class StringModel extends PrimitiveModel {
  static createEmptyValue = String;
  [_fromString] = String;
}
function makeEnumEmptyValueCreator(type) {
  const { [_enum]: enumObject } = createDetachedModel(type);
  const defaultValue = Object.values(enumObject)[0];
  return () => defaultValue;
}
class EnumModel extends AbstractModel {
  [_fromString](value) {
    return value in this[_enum] ? value : void 0;
  }
}
function* getObjectModelOwnAndParentGetters(model) {
  for (let proto = Object.getPrototypeOf(model); proto !== ObjectModel.prototype; proto = Object.getPrototypeOf(proto)) {
    const descriptors = Object.getOwnPropertyDescriptors(proto);
    for (const [name, { get }] of Object.entries(descriptors)) {
      if (get) {
        yield [name, get];
      }
    }
  }
}
function makeObjectEmptyValueCreator(type) {
  const model = createDetachedModel(type);
  return () => {
    const obj = {};
    for (const [key, getter] of getObjectModelOwnAndParentGetters(model)) {
      const propertyModel = getter.call(model);
      obj[key] = propertyModel[_optional] ? void 0 : propertyModel.constructor.createEmptyValue();
    }
    return obj;
  };
}
class ObjectModel extends AbstractModel {
  static createEmptyValue = makeObjectEmptyValueCreator(ObjectModel);
  #properties = {};
  [_getPropertyModel](key, init) {
    if (!this.#properties[key]) {
      this.#properties[key] = init(this, key);
    }
    return this.#properties[key];
  }
}
class ArrayModel extends AbstractModel {
  static createEmptyValue() {
    return [];
  }
  [_createEmptyItemValue];
  #createItem;
  #items = [];
  constructor(parent, key, optional, createItem, options) {
    super(parent, key, optional, options);
    this.#createItem = createItem;
    this[_createEmptyItemValue] = createItem(this, 0).constructor.createEmptyValue;
  }
  /**
   * Iterates the current array value and yields a binder node for every item.
   */
  *[Symbol.iterator]() {
    const array = this.valueOf();
    if (array.length !== this.#items.length) {
      this.#items.length = array.length;
    }
    for (let i = 0; i < array.length; i++) {
      let item = this.#items[i];
      if (!item) {
        item = this.#createItem(this, i);
        this.#items[i] = item;
      }
      yield getBinderNode(item);
    }
  }
}
export {
  AbstractModel,
  ArrayModel,
  BooleanModel,
  EnumModel,
  NumberModel,
  ObjectModel,
  PrimitiveModel,
  StringModel,
  _createEmptyItemValue,
  _enum,
  _fromString,
  _getPropertyModel,
  _key,
  _meta,
  _parent,
  _validators,
  createDetachedModel,
  getObjectModelOwnAndParentGetters,
  hasFromString,
  makeEnumEmptyValueCreator,
  makeObjectEmptyValueCreator,
  modelDetachedParent
};
//# sourceMappingURL=Models.js.map
