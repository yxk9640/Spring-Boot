import isAfter from "validator/es/lib/isAfter.js";
import isBefore from "validator/es/lib/isBefore.js";
import isBoolean from "validator/es/lib/isBoolean.js";
import isDecimal from "validator/es/lib/isDecimal.js";
import isEmail from "validator/es/lib/isEmail.js";
import isFloat from "validator/es/lib/isFloat.js";
import isLength from "validator/es/lib/isLength.js";
import isNumeric from "validator/es/lib/isNumeric.js";
import matches from "validator/es/lib/matches.js";
import toFloat from "validator/es/lib/toFloat.js";
class AbstractValidator {
  message = "invalid";
  impliesRequired = false;
  constructor(attrs) {
    if (attrs?.message) {
      this.message = attrs.message;
    }
  }
}
class Required extends AbstractValidator {
  impliesRequired = true;
  validate(value) {
    if (typeof value === "string" || Array.isArray(value)) {
      return value.length > 0;
    }
    if (typeof value === "number") {
      return Number.isFinite(value);
    }
    return value !== void 0;
  }
  name = "Required";
}
function _asValidatorAttributes(attrs) {
  return typeof attrs === "object" ? attrs : {};
}
function _value(attrs) {
  return typeof attrs === "object" ? attrs.value : attrs;
}
class NumberValidator extends AbstractValidator {
  validate(value) {
    return isNumeric(String(value));
  }
}
class IsNumber extends NumberValidator {
  optional;
  constructor(optional, attrs) {
    super({ message: "must be a number", ...attrs });
    this.optional = optional;
  }
  validate(value) {
    return this.optional && value == null || super.validate(value);
  }
  name = "IsNumber";
}
class ValueNumberValidator extends NumberValidator {
  value;
  constructor(attrs) {
    super(_asValidatorAttributes(attrs));
    const val = _value(attrs);
    this.value = typeof val === "string" ? parseFloat(val) : val;
  }
}
class Email extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be a well-formed email address", ...attrs });
  }
  validate(value) {
    return !value || isEmail(value);
  }
  name = "Email";
}
class Null extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be null", ...attrs });
  }
  validate(value) {
    return value == null;
  }
  name = "Null";
}
class NotNull extends Required {
  constructor(attrs) {
    super({ message: "must not be null", ...attrs });
  }
  validate(value) {
    return !new Null().validate(value);
  }
  name = "NotNull";
}
class NotEmpty extends Required {
  constructor(attrs) {
    super({ message: "must not be empty", ...attrs });
  }
  validate(value) {
    return super.validate(value) && new NotNull().validate(value) && (value.length ?? 0) > 0;
  }
  name = "NotEmpty";
}
class NotBlank extends Required {
  constructor(attrs) {
    super({ message: "must not be blank", ...attrs });
  }
  validate(value) {
    return super.validate(value) && new NotNull().validate(value) && String(value).trim().length > 0;
  }
  name = "NotBlank";
}
class AssertTrue extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be true", ...attrs });
  }
  validate(value) {
    return isBoolean(String(value)) && String(value) === "true";
  }
  name = "AssertTrue";
}
class AssertFalse extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be false", ...attrs });
  }
  validate(value) {
    return !new AssertTrue().validate(value);
  }
  name = "AssertFalse";
}
function _asValueNumberAttributes(attrs) {
  return typeof attrs === "object" ? attrs : { value: attrs };
}
class Min extends ValueNumberValidator {
  constructor(attrs) {
    super({
      message: `must be greater than or equal to ${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { min: this.value });
  }
  name = "Min";
}
class Max extends ValueNumberValidator {
  constructor(attrs) {
    super({
      message: `must be less than or equal to ${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { max: this.value });
  }
  name = "Max";
}
function _inclusive(attrs) {
  return typeof attrs !== "object" || attrs.inclusive !== false;
}
class DecimalMin extends ValueNumberValidator {
  inclusive;
  constructor(attrs) {
    super({
      message: `must be greater than ${_inclusive(attrs) ? "or equal to " : ""}${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
    this.inclusive = _inclusive(attrs);
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { [this.inclusive ? "min" : "gt"]: this.value });
  }
  name = "DecimalMin";
}
class DecimalMax extends ValueNumberValidator {
  inclusive;
  constructor(attrs) {
    super({
      message: `must be less than ${_inclusive(attrs) ? "or equal to " : ""}${_value(attrs)}`,
      ..._asValueNumberAttributes(attrs)
    });
    this.inclusive = _inclusive(attrs);
  }
  validate(value) {
    return super.validate(value) && isFloat(String(value), { [this.inclusive ? "max" : "lt"]: this.value });
  }
  name = "DecimalMax";
}
class Negative extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be less than 0", ...attrs });
  }
  validate(value) {
    return toFloat(String(value)) < 0;
  }
  name = "Negative";
}
class NegativeOrZero extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be less than or equal to 0", ...attrs });
  }
  validate(value) {
    return toFloat(String(value)) <= 0;
  }
  name = "NegativeOrZero";
}
class Positive extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be greater than 0", ...attrs });
  }
  validate(value) {
    return toFloat(String(value)) > 0;
  }
  name = "Positive";
}
class PositiveOrZero extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be greater than or equal to 0", ...attrs });
  }
  validate(value) {
    return toFloat(String(value)) >= 0;
  }
  name = "PositiveOrZero";
}
function _min(attrs) {
  return attrs.min ?? 0;
}
function _max(attrs) {
  return attrs.max ?? Number.MAX_SAFE_INTEGER;
}
class Size extends AbstractValidator {
  min;
  max;
  constructor(attrs = {}) {
    super({ message: `size must be between ${_min(attrs)} and ${_max(attrs)}`, ...attrs });
    this.min = _min(attrs);
    this.max = _max(attrs);
    if (this.min > 0) {
      this.impliesRequired = true;
    }
  }
  validate(value) {
    if (this.min && this.min > 0 && !new Required().validate(value)) {
      return false;
    }
    return isLength(value, { min: this.min, max: this.max });
  }
  name = "Size";
}
class Digits extends AbstractValidator {
  integer;
  fraction;
  constructor(attrs) {
    super({
      message: `numeric value out of bounds (<${attrs.integer} digits>.<${attrs.fraction} digits> expected)`,
      ...attrs
    });
    this.integer = attrs.integer;
    this.fraction = attrs.fraction;
  }
  validate(value) {
    return String(Math.floor(Math.abs(toFloat(String(value))))).length <= this.integer && // eslint-disable-next-line camelcase
    isDecimal(String(value), { decimal_digits: `0,${this.fraction}` });
  }
  name = "Digits";
}
class Past extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be a past date", ...attrs });
  }
  validate(value) {
    return isBefore(String(value));
  }
  name = "Past";
}
class Future extends AbstractValidator {
  constructor(attrs) {
    super({ message: "must be a future date", ...attrs });
  }
  validate(value) {
    return isAfter(String(value));
  }
  name = "Future";
}
function _regexp(attrs) {
  if (typeof attrs === "string") {
    return new RegExp(attrs, "u");
  }
  if (attrs instanceof RegExp) {
    return attrs;
  }
  if (typeof attrs.regexp === "string") {
    return new RegExp(attrs.regexp, "u");
  }
  return attrs.regexp;
}
class Pattern extends AbstractValidator {
  regexp;
  constructor(attrs) {
    super({
      message: `must match the following regular expression: ${_regexp(attrs).toString()}`,
      ..._asValidatorAttributes(attrs)
    });
    this.regexp = _regexp(attrs);
  }
  validate(value) {
    return matches(value, this.regexp);
  }
  name = "Pattern";
}
class ValidityStateValidator extends AbstractValidator {
  message = "";
  // eslint-disable-next-line no-useless-constructor,@typescript-eslint/no-useless-constructor
  constructor() {
    super();
  }
  validate() {
    return false;
  }
  name = "ValidityStateValidator";
}
export {
  AssertFalse,
  AssertTrue,
  DecimalMax,
  DecimalMin,
  Digits,
  Email,
  Future,
  IsNumber,
  Max,
  Min,
  Negative,
  NegativeOrZero,
  NotBlank,
  NotEmpty,
  NotNull,
  Null,
  Past,
  Pattern,
  Positive,
  PositiveOrZero,
  Required,
  Size,
  ValidityStateValidator
};
//# sourceMappingURL=Validators.js.map
