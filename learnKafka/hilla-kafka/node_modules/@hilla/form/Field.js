import { noChange, nothing } from "lit";
import { directive, Directive, PartType } from "lit/directive.js";
import { getBinderNode } from "./BinderNode.js";
import { _fromString, ArrayModel, BooleanModel, hasFromString, ObjectModel } from "./Models.js";
import { _validity, defaultValidity } from "./Validity.js";
const props = ["required", "invalid", "errorMessage", "value", "validity", "checkValidity"];
function isFieldElement(element) {
  return props.some((prop) => prop in element);
}
class AbstractFieldStrategy {
  model;
  #element;
  /**
   * @privateRemarks
   * Fallback for missing .validity property API in Vaadin components.
   */
  #validityFallback = defaultValidity;
  constructor(element, model) {
    this.#element = element;
    this.model = model;
  }
  get element() {
    return this.#element;
  }
  /**
   * @param element - the new element value
   * @deprecated will be read-only in future
   */
  set element(element) {
    this.#element = element;
  }
  get value() {
    return this.#element.value;
  }
  set value(value) {
    this.#element.value = value;
  }
  set errorMessage(_) {
  }
  get validity() {
    return this.#element.validity ?? this.#validityFallback;
  }
  checkValidity() {
    if (!this.#element.checkValidity) {
      return true;
    }
    const valid = this.#element.checkValidity();
    this.#validityFallback = {
      ...defaultValidity,
      valid,
      ...valid ? {} : this.#detectValidityError()
    };
    return valid;
  }
  setAttribute(key, val) {
    if (val) {
      this.#element.setAttribute(key, "");
    } else {
      this.#element.removeAttribute(key);
    }
  }
  removeEventListeners() {
  }
  #detectValidityError() {
    if (!("inputElement" in this.#element)) {
      return { customError: true };
    }
    const inputElement = this.#element.inputElement;
    if (this.#element.value === "") {
      if (inputElement.value === "") {
        return { valueMissing: true };
      }
      return { badInput: true };
    }
    return { customError: true };
  }
}
class VaadinFieldStrategy extends AbstractFieldStrategy {
  #invalid = false;
  #boundOnValidated = this.#onValidated.bind(this);
  constructor(element, model) {
    super(element, model);
    element.addEventListener("validated", this.#boundOnValidated);
  }
  set required(value) {
    this.element.required = value;
  }
  set invalid(value) {
    this.#invalid = value;
    this.element.invalid = value;
  }
  set errorMessage(value) {
    this.element.errorMessage = value;
  }
  removeEventListeners() {
    this.element.removeEventListener("validated", this.#boundOnValidated);
  }
  #onValidated(e) {
    if (!(e instanceof CustomEvent) || typeof e.detail !== "object") {
      return;
    }
    const invalid = !e.detail.valid;
    if (this.#invalid !== invalid) {
      this.element.invalid = this.#invalid;
    }
  }
}
class GenericFieldStrategy extends AbstractFieldStrategy {
  set required(value) {
    this.setAttribute("required", value);
  }
  set invalid(value) {
    this.setAttribute("invalid", value);
  }
}
class CheckedFieldStrategy extends GenericFieldStrategy {
  get value() {
    if (this.model instanceof BooleanModel) {
      return this.element.checked;
    }
    return this.element.checked ? this.element.value : void 0;
  }
  set value(val) {
    this.element.checked = /^(true|on)$/iu.test(String(val));
  }
}
class ComboBoxFieldStrategy extends VaadinFieldStrategy {
  get value() {
    if (this.model && (this.model instanceof ObjectModel || this.model instanceof ArrayModel)) {
      const { selectedItem } = this.element;
      return selectedItem ?? void 0;
    }
    return super.value;
  }
  set value(val) {
    if (this.model instanceof ObjectModel || this.model instanceof ArrayModel) {
      this.element.selectedItem = val ?? null;
    } else {
      super.value = val;
    }
  }
}
class VaadinStringFieldStrategy extends VaadinFieldStrategy {
  get value() {
    return super.value;
  }
  set value(val) {
    super.value = val ?? "";
  }
}
class MultiSelectComboBoxFieldStrategy extends VaadinFieldStrategy {
  get value() {
    return this.element.selectedItems;
  }
  set value(val) {
    this.element.selectedItems = val;
  }
}
class SelectedFieldStrategy extends GenericFieldStrategy {
  get value() {
    return this.element.selected;
  }
  set value(val) {
    this.element.selected = val;
  }
}
function getDefaultFieldStrategy(elm, model) {
  switch (elm.localName) {
    case "vaadin-checkbox":
    case "vaadin-radio-button":
      return new CheckedFieldStrategy(elm, model);
    case "vaadin-combo-box":
      return new ComboBoxFieldStrategy(elm, model);
    case "vaadin-list-box":
      return new SelectedFieldStrategy(elm, model);
    case "vaadin-multi-select-combo-box":
      return new MultiSelectComboBoxFieldStrategy(elm, model);
    case "vaadin-rich-text-editor":
      return new GenericFieldStrategy(elm, model);
    case "vaadin-time-picker":
      return new VaadinStringFieldStrategy(
        elm,
        model
      );
    default:
      if (elm.localName === "input" && /^(checkbox|radio)$/u.test(elm.type)) {
        return new CheckedFieldStrategy(elm, model);
      }
      return elm.constructor.version ? new VaadinFieldStrategy(elm, model) : new GenericFieldStrategy(elm, model);
  }
}
function convertFieldValue(model, fieldValue) {
  return typeof fieldValue === "string" && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;
}
const field = directive(
  class extends Directive {
    fieldState;
    constructor(partInfo) {
      super(partInfo);
      if (partInfo.type !== PartType.PROPERTY && partInfo.type !== PartType.ELEMENT) {
        throw new Error('Use as "<element {field(...)}" or <element ...={field(...)}"');
      }
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    render(_model, _effect) {
      return nothing;
    }
    update(part, [model, effect]) {
      const element = part.element;
      const binderNode = getBinderNode(model);
      if (!this.fieldState) {
        const fieldState2 = {
          errorMessage: "",
          name: "",
          value: "",
          required: false,
          invalid: false,
          model,
          validity: defaultValidity,
          element,
          strategy: binderNode.binder.getFieldStrategy(element, model)
        };
        this.fieldState = fieldState2;
        const updateValueFromElement = () => {
          fieldState2.strategy.checkValidity();
          if (!fieldState2.strategy.validity.badInput) {
            fieldState2.value = fieldState2.strategy.value;
          }
          fieldState2.validity = fieldState2.strategy.validity;
          binderNode[_validity] = fieldState2.validity;
          binderNode.value = convertFieldValue(model, fieldState2.value);
          if (effect !== void 0) {
            effect.call(element, element);
          }
        };
        element.addEventListener("input", updateValueFromElement);
        const changeBlurHandler = () => {
          updateValueFromElement();
          binderNode.visited = true;
        };
        element.addEventListener("blur", changeBlurHandler);
        element.addEventListener("change", changeBlurHandler);
      }
      const { fieldState } = this;
      if (fieldState.element !== element || fieldState.model !== model) {
        fieldState.strategy = binderNode.binder.getFieldStrategy(element, model);
      }
      const { name } = binderNode;
      if (name !== fieldState.name) {
        fieldState.name = name;
        element.setAttribute("name", name);
      }
      const { value } = binderNode;
      const valueFromField = convertFieldValue(model, fieldState.value);
      if (value !== valueFromField && !(Number.isNaN(value) && Number.isNaN(valueFromField))) {
        fieldState.value = value;
        fieldState.strategy.value = value;
      }
      const { required } = binderNode;
      if (required !== fieldState.required) {
        fieldState.required = required;
        fieldState.strategy.required = required;
      }
      const firstError = binderNode.ownErrors[0];
      const errorMessage = firstError?.message || "";
      if (errorMessage !== fieldState.errorMessage) {
        fieldState.errorMessage = errorMessage;
        fieldState.strategy.errorMessage = errorMessage;
      }
      const { invalid } = binderNode;
      if (invalid !== fieldState.invalid) {
        fieldState.invalid = invalid;
        fieldState.strategy.invalid = invalid;
      }
      return noChange;
    }
  }
);
export {
  AbstractFieldStrategy,
  CheckedFieldStrategy,
  ComboBoxFieldStrategy,
  GenericFieldStrategy,
  MultiSelectComboBoxFieldStrategy,
  SelectedFieldStrategy,
  VaadinFieldStrategy,
  VaadinStringFieldStrategy,
  field,
  getDefaultFieldStrategy,
  isFieldElement
};
//# sourceMappingURL=Field.js.map
