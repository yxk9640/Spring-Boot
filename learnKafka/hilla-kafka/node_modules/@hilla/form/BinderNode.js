import {
  _createEmptyItemValue,
  _key,
  _parent,
  _validators,
  AbstractModel,
  ArrayModel,
  getObjectModelOwnAndParentGetters,
  ObjectModel
} from "./Models.js";
import { ValidityStateValidator } from "./Validators.js";
import { _validity } from "./Validity.js";
const _updateValidation = Symbol("updateValidation");
const _update = Symbol("update");
const _setErrorsWithDescendants = Symbol("setErrorsWithDescendants");
const _clearValidation = Symbol("clearValidation");
const nodes = /* @__PURE__ */ new WeakMap();
function getBinderNode(model) {
  let node = nodes.get(model);
  if (!node) {
    node = new BinderNode(model);
    nodes.set(model, node);
  }
  return node;
}
function getErrorPropertyName(valueError) {
  return typeof valueError.property === "string" ? valueError.property : getBinderNode(valueError.property).name;
}
function updateObjectOrArrayKey(model, value, key, keyValue) {
  if (model instanceof ObjectModel) {
    return {
      ...value,
      [key]: keyValue
    };
  }
  if (keyValue === void 0) {
    throw new TypeError("Unexpected undefined value");
  }
  if (model instanceof ArrayModel) {
    const array = value.slice();
    array[key] = keyValue;
    return array;
  }
  throw new TypeError(`Unknown model type ${model.constructor.name}`);
}
const CHANGED = new Event("binder-node-changed");
class NotArrayModelError extends Error {
  constructor() {
    super("The model does not represent array");
  }
}
class NotArrayItemModelError extends Error {
  constructor() {
    super("The model does not represent array item");
  }
}
const defaultArrayItemCache = /* @__PURE__ */ new WeakMap();
class BinderNode extends EventTarget {
  model;
  /**
   * The validity state read from the bound element, if any. Represents the
   * HTML element internal validation.
   *
   * For elements with `validity.valid === false`, the value in the
   * bound element is considered as invalid.
   */
  [_validity];
  #ownErrors;
  #validators;
  #validityStateValidator;
  #visited = false;
  constructor(model) {
    super();
    this.model = model;
    nodes.set(model, this);
    this.#validityStateValidator = new ValidityStateValidator();
    this.#validators = model[_validators];
    if (this.constructor === BinderNode) {
      this.initializeValue();
    }
  }
  /**
   * The binder for the top-level model.
   */
  get binder() {
    const binder = this.parent?.binder;
    if (!binder) {
      throw new TypeError("BinderNode is detached");
    }
    return binder;
  }
  /**
   * The default value related to the model
   */
  get defaultValue() {
    const key = this.model[_key];
    const parentDefaultValue = this.parent.defaultValue;
    if (this.#isArrayItem() && !(key in parentDefaultValue)) {
      if (defaultArrayItemCache.has(this.parent)) {
        return defaultArrayItemCache.get(this.parent);
      }
      const value = this.model.constructor.createEmptyValue();
      defaultArrayItemCache.set(this.parent, value);
      return value;
    }
    return parentDefaultValue[key];
  }
  /**
   * True if the current value is different from the defaultValue.
   */
  get dirty() {
    return this.value !== this.defaultValue;
  }
  /**
   * The combined array of all errors for this nodeâ€™s model and all its nested
   * models
   */
  get errors() {
    return [...Array.from(this.#getChildBinderNodes(), (node) => node.errors).flat(), ...this.ownErrors];
  }
  /**
   * Indicates if there is any error for the node's model.
   */
  get invalid() {
    return this.errors.length > 0;
  }
  /**
   * The name generated from the model structure, used to set the name
   * attribute on the field components.
   */
  get name() {
    let { model } = this;
    let name = "";
    while (model[_parent] instanceof AbstractModel) {
      name = `${String(model[_key])}${name ? `.${name}` : ""}`;
      model = model[_parent];
    }
    return name;
  }
  /**
   * The array of validation errors directly related with the model.
   */
  get ownErrors() {
    return this.#ownErrors ? this.#ownErrors : [];
  }
  /**
   * The parent node, if this binder node corresponds to a nested model,
   * otherwise undefined for the top-level binder.
   */
  get parent() {
    const modelParent = this.model[_parent];
    return modelParent instanceof AbstractModel ? getBinderNode(modelParent) : void 0;
  }
  /**
   * True if the value is required to be non-empty.
   */
  get required() {
    return this.#validators.some((validator) => validator.impliesRequired);
  }
  /**
   * The array of validators for the model. The default value is defined in the
   * model.
   */
  get validators() {
    return this.#validators;
  }
  set validators(validators) {
    this.#validators = validators;
    this.dispatchEvent(CHANGED);
  }
  /**
   * The current value related to the model
   */
  get value() {
    if (!this.parent) {
      return void 0;
    }
    let { value } = this.parent;
    if (value === void 0) {
      this.parent.initializeValue(true);
      ({ value } = this.parent);
    }
    const key = this.model[_key];
    return value[key];
  }
  set value(value) {
    this.initializeValue();
    this.#setValueState(value, void 0);
  }
  /**
   * True if the bound field was ever focused and blurred by the user.
   */
  get visited() {
    return this.#visited;
  }
  set visited(v) {
    if (this.#visited !== v) {
      this.#visited = v;
      this[_updateValidation]().catch(() => {
      });
      this.dispatchEvent(CHANGED);
    }
  }
  /**
   * A helper method to add a validator
   *
   * @param validator - a validator
   */
  addValidator(validator) {
    this.validators = [...this.#validators, validator];
    this.dispatchEvent(CHANGED);
  }
  /**
   * Append an item to the array value.
   *
   * Requires the context model to be an array reference.
   *
   * @param item - optional new item value, an empty item is
   * appended if the argument is omitted
   */
  appendItem(item) {
    if (this.#isArray()) {
      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();
      const newValue = [...this.value ?? [], itemValueOrEmptyValue];
      const newDefaultValue = [...this.defaultValue ?? [], itemValueOrEmptyValue];
      this.#setValueState(newValue, newDefaultValue);
    } else {
      throw new NotArrayModelError();
    }
  }
  /**
   * Returns a binder node for the nested model instance.
   *
   * @param model - The nested model instance
   */
  for(model) {
    const binderNode = getBinderNode(model);
    if (binderNode.binder !== this.binder) {
      throw new Error("Unknown binder");
    }
    return binderNode;
  }
  prependItem(item) {
    if (this.#isArray()) {
      const itemValueOrEmptyValue = item ?? this.model[_createEmptyItemValue]();
      const newValue = [itemValueOrEmptyValue, ...this.value ?? []];
      const newDefaultValue = [itemValueOrEmptyValue, ...this.defaultValue ?? []];
      this.#setValueState(newValue, newDefaultValue);
    } else {
      throw new NotArrayModelError();
    }
  }
  removeSelf() {
    if (this.#isArrayItem()) {
      const newValue = (this.parent.value ?? []).filter((_, i) => i !== this.model[_key]);
      const newDefaultValue = (this.parent.defaultValue ?? []).filter((_, i) => i !== this.model[_key]);
      this.parent.#setValueState(newValue, newDefaultValue);
    } else {
      throw new NotArrayItemModelError();
    }
  }
  /**
   * Runs all validation callbacks potentially affecting this
   * or any nested model. Returns the combined array of all
   * errors as in the errors property.
   */
  async validate() {
    const errors = await Promise.all([
      ...this.#requestValidationOfDescendants(),
      ...this.#requestValidationWithAncestors()
    ]).then((arr) => arr.flat());
    this[_setErrorsWithDescendants](errors.length ? errors : void 0);
    this[_update]();
    return errors;
  }
  [_clearValidation]() {
    if (this.#visited) {
      this.#visited = false;
      this.dispatchEvent(CHANGED);
    }
    let needsUpdate = false;
    if (this.#ownErrors) {
      this.#ownErrors = void 0;
      needsUpdate = true;
      this.dispatchEvent(CHANGED);
    }
    if ([...this.#getChildBinderNodes()].filter((childBinderNode) => childBinderNode[_clearValidation]()).length > 0) {
      needsUpdate = true;
    }
    return needsUpdate;
  }
  [_setErrorsWithDescendants](errors) {
    const { name } = this;
    const ownErrors = errors ? errors.filter((valueError) => getErrorPropertyName(valueError) === name) : void 0;
    const relatedErrors = errors ? errors.filter((valueError) => getErrorPropertyName(valueError).startsWith(name)) : void 0;
    this.#ownErrors = ownErrors;
    for (const childBinderNode of this.#getChildBinderNodes()) {
      childBinderNode[_setErrorsWithDescendants](relatedErrors);
    }
    this.dispatchEvent(CHANGED);
  }
  [_update](_) {
    if (this.parent) {
      this.parent[_update]();
    }
  }
  async [_updateValidation]() {
    if (this.#visited) {
      await this.validate();
    } else if (this.dirty || this.invalid) {
      await Promise.all(
        [...this.#getChildBinderNodes()].map(async (childBinderNode) => childBinderNode[_updateValidation]())
      );
    }
  }
  *#getChildBinderNodes() {
    if (this.value === void 0 || this.defaultValue === void 0) {
      return;
    }
    if (this.#isObject()) {
      for (const [, getter] of getObjectModelOwnAndParentGetters(this.model)) {
        const childModel = getter.call(this.model);
        if (childModel[_key] in this.defaultValue) {
          yield getBinderNode(childModel);
        }
      }
    } else if (this.#isArray()) {
      for (const childBinderNode of this.model) {
        yield childBinderNode;
      }
    }
  }
  #isArray() {
    return this.model instanceof ArrayModel;
  }
  #isArrayItem() {
    return this.model[_parent] instanceof ArrayModel;
  }
  #isObject() {
    return this.model instanceof ObjectModel;
  }
  *#requestValidationOfDescendants() {
    for (const node of this.#getChildBinderNodes()) {
      yield* node.#runOwnValidators();
      yield* node.#requestValidationOfDescendants();
    }
  }
  *#requestValidationWithAncestors() {
    yield* this.#runOwnValidators();
    if (this.parent) {
      yield* this.parent.#requestValidationWithAncestors();
    }
  }
  *#runOwnValidators() {
    const hasInvalidState = this[_validity] && !this[_validity].valid;
    const hasBadInput = !!this[_validity]?.badInput;
    if (hasInvalidState && !hasBadInput || !hasInvalidState) {
      for (const validator of this.#validators) {
        yield this.binder.requestValidation(this.model, validator);
      }
    }
    if (hasInvalidState) {
      yield this.binder.requestValidation(this.model, this.#validityStateValidator);
    }
  }
  initializeValue(forceInitialize = false) {
    if (this.parent && (this.parent.value === void 0 || this.parent.defaultValue === void 0)) {
      this.parent.initializeValue(true);
    }
    const key = this.model[_key];
    let value = this.parent ? this.parent.value[this.model[_key]] : void 0;
    const defaultValue = this.parent ? this.parent.defaultValue[this.model[_key]] : void 0;
    if (value === void 0) {
      if (forceInitialize || !this.parent) {
        value = this.model.constructor.createEmptyValue();
        this.#setValueState(value, defaultValue === void 0 ? value : defaultValue);
      } else if (this.parent.model instanceof ObjectModel && !(key in (this.parent.value || {}))) {
        this.#setValueState(void 0, defaultValue === void 0 ? value : defaultValue);
      }
    }
  }
  #setValueState(value, defaultValue) {
    const { parent } = this;
    if (parent) {
      const key = this.model[_key];
      const parentValue = updateObjectOrArrayKey(parent.model, parent.value, key, value);
      const keepPristine = value === defaultValue && parent.value === parent.defaultValue;
      if (keepPristine) {
        parent.#setValueState(parentValue, parentValue);
      } else if (defaultValue !== void 0) {
        const parentDefaultValue = updateObjectOrArrayKey(parent.model, parent.defaultValue, key, defaultValue);
        parent.#setValueState(parentValue, parentDefaultValue);
      } else {
        parent.#setValueState(parentValue, void 0);
      }
    } else {
      const binder = this;
      if (defaultValue !== void 0) {
        binder.defaultValue = defaultValue;
      }
      binder.value = value;
    }
  }
}
export {
  BinderNode,
  CHANGED,
  _clearValidation,
  _setErrorsWithDescendants,
  _update,
  _updateValidation,
  getBinderNode
};
//# sourceMappingURL=BinderNode.js.map
