{
  "version": 3,
  "sources": ["src/Models.ts"],
  "sourcesContent": ["import isNumeric from 'validator/es/lib/isNumeric.js';\nimport { type BinderNode, getBinderNode } from './BinderNode.js';\nimport type { Validator } from './Validation.js';\nimport { IsNumber } from './Validators.js';\n\nexport const _createEmptyItemValue = Symbol('itemModel');\nexport const _parent = Symbol('parent');\nexport const _key = Symbol('key');\nexport const _fromString = Symbol('fromString');\nexport const _validators = Symbol('validators');\nexport const _meta = Symbol('meta');\nexport const _getPropertyModel = Symbol('getPropertyModel');\nexport const _enum = Symbol('enum');\n\nconst _optional = Symbol('optional');\n\nexport interface HasFromString<T> {\n  [_fromString](value: string): T;\n}\n\nexport function hasFromString<T>(model: AbstractModel<T>): model is AbstractModel<T> & HasFromString<T> {\n  return _fromString in model;\n}\n\nexport type Value<M> = M extends AbstractModel<infer T> ? T : never;\n\nexport const modelDetachedParent = { $value$: undefined };\n\nexport type ModelParent = AbstractModel | BinderNode | typeof modelDetachedParent;\n\nexport interface Annotation {\n  name: string;\n  attributes?: Record<string, unknown>;\n}\n\nexport interface ModelMetadata {\n  javaType?: string;\n  annotations?: Annotation[];\n}\n\nexport interface ModelOptions<T> {\n  validators?: ReadonlyArray<Validator<T>>;\n  meta?: ModelMetadata;\n}\n\nexport type DetachedModelConstructor<M> = {\n  prototype: object;\n  new (parent: typeof modelDetachedParent, key: '$value$', optional: boolean): M;\n};\n\nexport function createDetachedModel<M extends AbstractModel>(type: DetachedModelConstructor<M>): M {\n  return new type(modelDetachedParent, '$value$', false);\n}\n\nexport abstract class AbstractModel<T = unknown> {\n  static createEmptyValue(): unknown {\n    return undefined;\n  }\n\n  declare readonly ['constructor']: typeof AbstractModel<T>;\n\n  readonly [_parent]?: ModelParent;\n\n  readonly [_validators]: ReadonlyArray<Validator<T>>;\n\n  readonly [_meta]: ModelMetadata;\n\n  readonly [_optional]: boolean;\n\n  [_key]: keyof any;\n\n  constructor(parent: ModelParent, key: keyof any, optional: boolean, options?: ModelOptions<T>) {\n    this[_parent] = parent;\n    this[_key] = key;\n    this[_optional] = optional;\n    this[_validators] = options?.validators ?? [];\n    this[_meta] = options?.meta ?? {};\n  }\n\n  toString(): string {\n    return String(this.valueOf());\n  }\n\n  valueOf(): T {\n    const { value } = getBinderNode(this);\n\n    if (value === undefined) {\n      throw new TypeError('Value is undefined');\n    }\n\n    return value! as T;\n  }\n}\n\nexport abstract class PrimitiveModel<T> extends AbstractModel<T> {}\n\nexport class BooleanModel extends PrimitiveModel<boolean> implements HasFromString<boolean> {\n  static override createEmptyValue = Boolean;\n\n  [_fromString](str: string): boolean {\n    // This implementation matches the values accepted by validator.js and converts all other values to false\n    // See https://github.com/validatorjs/validator.js/blob/master/src/lib/isBoolean.js\n    return ['true', '1', 'yes'].includes(str.toLowerCase());\n  }\n}\n\nexport class NumberModel extends PrimitiveModel<number> implements HasFromString<number | undefined> {\n  static override createEmptyValue = Number;\n\n  constructor(parent: ModelParent, key: keyof any, optional: boolean, options?: ModelOptions<number>) {\n    // Prepend a built-in validator to indicate NaN input\n    const validators = [new IsNumber(optional), ...(options?.validators ?? [])];\n    super(parent, key, optional, { ...options, validators });\n  }\n\n  [_fromString](str: string): number | undefined {\n    // Returning undefined is needed to support passing the validation when the value of an optional number field is\n    // an empty string\n    if (str === '') return undefined;\n    return isNumeric(str) ? Number.parseFloat(str) : NaN;\n  }\n}\n\nexport class StringModel extends PrimitiveModel<string> implements HasFromString<string> {\n  static override createEmptyValue = String;\n  [_fromString] = String;\n}\n\ndeclare enum Enum {}\n\nexport function makeEnumEmptyValueCreator<M extends EnumModel>(type: DetachedModelConstructor<M>): () => Value<M> {\n  const { [_enum]: enumObject } = createDetachedModel(type);\n  const defaultValue = Object.values(enumObject)[0] as Value<M>;\n\n  return () => defaultValue;\n}\n\nexport abstract class EnumModel<E extends typeof Enum = typeof Enum>\n  extends AbstractModel<E[keyof E]>\n  implements HasFromString<E[keyof E] | undefined>\n{\n  abstract readonly [_enum]: E;\n\n  [_fromString](value: string): E[keyof E] | undefined {\n    return value in this[_enum] ? (value as E[keyof E]) : undefined;\n  }\n}\n\nexport function* getObjectModelOwnAndParentGetters<M extends ObjectModel>(\n  model: M,\n): Generator<readonly [key: keyof Value<M>, getter: () => AbstractModel]> {\n  for (\n    let proto = Object.getPrototypeOf(model);\n    proto !== ObjectModel.prototype;\n    proto = Object.getPrototypeOf(proto)\n  ) {\n    const descriptors = Object.getOwnPropertyDescriptors(proto);\n    for (const [name, { get }] of Object.entries(descriptors)) {\n      if (get) {\n        yield [name as keyof Value<M>, get];\n      }\n    }\n  }\n}\n\nexport function makeObjectEmptyValueCreator<M extends ObjectModel>(type: DetachedModelConstructor<M>): () => Value<M> {\n  const model = createDetachedModel(type);\n\n  return () => {\n    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n    const obj: Partial<Value<M>> = {};\n\n    // Iterate the model class hierarchy up to the ObjectModel, and extract\n    // the property getter names from every prototypes\n    for (const [key, getter] of getObjectModelOwnAndParentGetters(model)) {\n      const propertyModel = getter.call(model);\n      obj[key] = (\n        propertyModel[_optional] ? undefined : propertyModel.constructor.createEmptyValue()\n      ) as Value<M>[keyof Value<M>];\n    }\n\n    return obj as Value<M>;\n  };\n}\n\ntype ChildModel<T extends Record<never, never>, K extends keyof T> = AbstractModel<NonNullable<T[K]>>;\n\nexport class ObjectModel<T extends Record<never, never> = Record<never, never>> extends AbstractModel<T> {\n  static override createEmptyValue = makeObjectEmptyValueCreator(ObjectModel);\n\n  #properties: { [K in keyof T]?: ChildModel<T, K> } = {};\n\n  protected [_getPropertyModel]<K extends keyof T, M extends ChildModel<T, K>>(\n    key: K,\n    init: (parent: this, key: K) => M,\n  ): M {\n    if (!this.#properties[key]) {\n      this.#properties[key] = init(this, key);\n    }\n\n    return this.#properties[key] as M;\n  }\n}\n\nexport type ArrayItemModel<M> = M extends ArrayModel<infer MItem> ? MItem : never;\n\nexport class ArrayModel<MItem extends AbstractModel = AbstractModel> extends AbstractModel<Array<Value<MItem>>> {\n  static override createEmptyValue(): [] {\n    return [];\n  }\n\n  [_createEmptyItemValue]: () => Value<MItem>;\n\n  readonly #createItem: (parent: this, index: number) => MItem;\n  #items: Array<MItem | undefined> = [];\n\n  constructor(\n    parent: ModelParent,\n    key: keyof any,\n    optional: boolean,\n    createItem: (parent: ArrayModel<MItem>, key: number) => MItem,\n    options?: ModelOptions<Array<Value<MItem>>>,\n  ) {\n    super(parent, key, optional, options);\n    this.#createItem = createItem;\n    this[_createEmptyItemValue] = createItem(this, 0).constructor.createEmptyValue as () => Value<MItem>;\n  }\n\n  /**\n   * Iterates the current array value and yields a binder node for every item.\n   */\n  *[Symbol.iterator](): IterableIterator<BinderNode<MItem>> {\n    const array = this.valueOf();\n\n    if (array.length !== this.#items.length) {\n      this.#items.length = array.length;\n    }\n\n    for (let i = 0; i < array.length; i++) {\n      let item: MItem | undefined = this.#items[i];\n\n      if (!item) {\n        item = this.#createItem(this, i);\n        this.#items[i] = item;\n      }\n\n      yield getBinderNode(item);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
