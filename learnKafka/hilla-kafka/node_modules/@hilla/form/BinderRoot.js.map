{
  "version": 3,
  "sources": ["src/BinderRoot.ts"],
  "sourcesContent": ["import { EndpointValidationError, type ValidationErrorData } from '@hilla/frontend/EndpointErrors.js';\nimport {\n  _clearValidation,\n  _setErrorsWithDescendants,\n  _update,\n  _updateValidation,\n  BinderNode,\n  CHANGED,\n} from './BinderNode.js';\nimport { type FieldElement, type FieldStrategy, getDefaultFieldStrategy } from './Field.js';\nimport {\n  _parent,\n  type AbstractModel,\n  createDetachedModel,\n  type DetachedModelConstructor,\n  type Value,\n} from './Models.js';\nimport type { ClassStaticProperties } from './types.js';\nimport {\n  type InterpolateMessageCallback,\n  runValidator,\n  ServerValidator,\n  ValidationError,\n  type Validator,\n  type ValueError,\n} from './Validation.js';\n\nexport type BinderConfiguration<T> = Readonly<{\n  onChange?(oldValue?: T): void;\n  onSubmit?(value: T): Promise<T | undefined | void>;\n}>;\n\nexport type BinderRootConfiguration<T> = BinderConfiguration<T> &\n  Readonly<{\n    context?: unknown;\n  }>;\n\n/**\n * A simplified Binder that does not require a context.\n * It can be used as root when there is no Element to use as context.\n *\n * @typeParam T - Type of the value that binds to a form\n * @typeParam M - Type of the model that describes the structure of the value\n */\nexport class BinderRoot<M extends AbstractModel = AbstractModel> extends BinderNode<M> {\n  static interpolateMessageCallback?: InterpolateMessageCallback<any>;\n\n  #defaultValue!: Value<M>; // Initialized in the `read()` method\n\n  #value!: Value<M>; // Initialized in the `read()` method\n\n  readonly #emptyValue: Value<M>;\n\n  #submitting = false;\n\n  #validating = false;\n\n  #validationRequest?: Promise<void>;\n\n  readonly #config?: BinderRootConfiguration<Value<M>>;\n\n  readonly #validations = new Map<AbstractModel, Map<Validator, Promise<readonly ValueError[]>>>();\n\n  readonly #context: unknown = this;\n\n  declare readonly ['constructor']: ClassStaticProperties<typeof BinderRoot<M>>;\n\n  /**\n   *\n   * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model\n   * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.\n   *\n   * ```\n   * binder = new BinderRoot(OrderModel);\n   * or\n   * binder = new BinderRoot(OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});\n   * ```\n   */\n  constructor(Model: DetachedModelConstructor<M>, config?: BinderRootConfiguration<Value<M>>) {\n    super(createDetachedModel(Model));\n    // @ts-expect-error the model's parent is the binder\n    this.model[_parent] = this;\n    this.#context = config?.context ?? this;\n    this.#config = config;\n    // Initialize value instead of the parent.\n    this.initializeValue(true);\n    this.#emptyValue = this.value;\n  }\n\n  /**\n   * The initial value of the form, before any fields are edited by the user.\n   */\n  override get defaultValue(): Value<M> {\n    return this.#defaultValue;\n  }\n\n  override set defaultValue(newValue: Value<M>) {\n    this.#defaultValue = newValue;\n    this.dispatchEvent(CHANGED);\n  }\n\n  override get binder(): BinderRoot {\n    return this as BinderRoot;\n  }\n\n  /**\n   * The current value of the form.\n   */\n  override get value(): Value<M> {\n    return this.#value;\n  }\n\n  override set value(newValue: Value<M>) {\n    if (newValue === this.#value) {\n      return;\n    }\n\n    const oldValue = this.#value;\n    this.#value = newValue;\n    this[_update](oldValue);\n    this[_updateValidation]().catch(() => {});\n  }\n\n  /**\n   * Indicates the submitting status of the form.\n   * True if the form was submitted, but the submit promise is not resolved yet.\n   */\n  get submitting(): boolean {\n    return this.#submitting;\n  }\n\n  /**\n   * Indicates the validating status of the form.\n   * True when there is an ongoing validation.\n   */\n  get validating(): boolean {\n    return this.#validating;\n  }\n\n  /**\n   * Read the given value into the form and clear validation errors. Clears the form if the value is undefined.\n   *\n   * @param value - The value to read, or undefined to clear.\n   */\n  read(value: Value<M> | null | undefined): void {\n    if (value === undefined || value === null) {\n      this.clear();\n      return;\n    }\n    this.defaultValue = value;\n    if (\n      // Skip when no value is set yet (e.g., invoked from constructor)\n      this.value &&\n      // Clear validation state, then proceed if update is needed\n      this[_clearValidation]() &&\n      // When value is dirty, another update is coming from invoking the value\n      // setter below, so we skip this one to prevent duplicate updates\n      this.value === value\n    ) {\n      this[_update](this.value);\n    }\n\n    this.value = this.defaultValue;\n  }\n\n  /**\n   * Reset the form to the previous value\n   */\n  reset(): void {\n    this.read(this.#defaultValue);\n  }\n\n  /**\n   * Sets the form to empty value, as defined in the Model.\n   */\n  clear(): void {\n    this.read(this.#emptyValue);\n  }\n\n  /**\n   * Submit the current form value to a predefined\n   * onSubmit callback.\n   *\n   * It's a no-op if the onSubmit callback is undefined.\n   */\n  async submit(): Promise<Value<M> | undefined | void> {\n    const onSubmit = this.#config?.onSubmit;\n    if (onSubmit) {\n      return this.submitTo(onSubmit);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Submit the current form value to callback\n   *\n   * @param endpointMethod - the callback function\n   */\n  async submitTo<V>(endpointMethod: (value: Value<M>) => Promise<V>): Promise<V> {\n    const errors = await this.validate();\n    if (errors.length) {\n      throw new ValidationError(errors);\n    }\n\n    this.#submitting = true;\n    this[_update](this.value);\n    this.dispatchEvent(CHANGED);\n    try {\n      return await endpointMethod.call(this.#context, this.value);\n    } catch (error: unknown) {\n      if (error instanceof EndpointValidationError && error.validationErrorData.length) {\n        const valueErrors: Array<ValueError<any>> = [];\n        error.validationErrorData.forEach((data: ValidationErrorData) => {\n          const res =\n            /Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(\n              data.message,\n            );\n          const [property, value, message] = res ? res.splice(2) : [data.parameterName ?? '', undefined, data.message];\n          valueErrors.push({\n            message,\n            property,\n            validator: new ServerValidator(message),\n            value,\n          });\n        });\n        this[_setErrorsWithDescendants](valueErrors);\n        throw new ValidationError(valueErrors);\n      }\n\n      throw error;\n    } finally {\n      this.#submitting = false;\n      this.defaultValue = this.value;\n      this[_update](this.value);\n    }\n  }\n\n  async requestValidation<NM extends AbstractModel>(\n    model: NM,\n    validator: Validator<Value<NM>>,\n  ): Promise<ReadonlyArray<ValueError<Value<NM>>>> {\n    let modelValidations: Map<Validator<Value<NM>>, Promise<ReadonlyArray<ValueError<Value<NM>>>>>;\n\n    if (this.#validations.has(model)) {\n      modelValidations = this.#validations.get(model) as Map<\n        Validator<Value<NM>>,\n        Promise<ReadonlyArray<ValueError<Value<NM>>>>\n      >;\n    } else {\n      modelValidations = new Map();\n      this.#validations.set(model, modelValidations);\n    }\n\n    await this.performValidation();\n\n    if (modelValidations.has(validator)) {\n      return modelValidations.get(validator)!;\n    }\n\n    const promise = runValidator(model, validator, this.constructor.interpolateMessageCallback);\n    modelValidations.set(validator, promise);\n    const valueErrors = await promise;\n\n    modelValidations.delete(validator);\n    if (modelValidations.size === 0) {\n      this.#validations.delete(model);\n    }\n    if (this.#validations.size === 0) {\n      this.completeValidation();\n    }\n\n    return valueErrors;\n  }\n\n  /**\n   * Determines and returns the field directive strategy for the bound element.\n   * Override to customise the binding strategy for a component.\n   * The Binder extends BinderNode, see the inherited properties and methods below.\n   *\n   * @param elm - the bound element\n   * @param model - the bound model\n   */\n  getFieldStrategy<TField>(elm: HTMLElement, model?: AbstractModel<TField>): FieldStrategy {\n    return getDefaultFieldStrategy(elm as FieldElement, model);\n  }\n\n  protected performValidation(): Promise<void> | void {\n    if (!this.#validationRequest) {\n      this.#validating = true;\n      this.dispatchEvent(CHANGED);\n      this.#validationRequest = Promise.resolve().then(() => {\n        this.#validationRequest = undefined;\n      });\n    }\n    return this.#validationRequest;\n  }\n\n  protected completeValidation(): void {\n    this.#validating = false;\n    this.dispatchEvent(CHANGED);\n  }\n\n  protected override [_update](oldValue: Value<M>): void {\n    this.#config?.onChange?.call(this.#context, oldValue);\n    this.dispatchEvent(CHANGED);\n  }\n}\n"],
  "mappings": "AAAA,SAAS,+BAAyD;AAClE;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAgD,+BAA+B;AAC/E;AAAA,EACE;AAAA,EAEA;AAAA,OAGK;AAEP;AAAA,EAEE;AAAA,EACA;AAAA,EACA;AAAA,OAGK;AAmBA,MAAM,mBAA4D,WAAc;AAAA,EACrF,OAAO;AAAA,EAEP;AAAA;AAAA,EAEA;AAAA;AAAA,EAES;AAAA,EAET,cAAc;AAAA,EAEd,cAAc;AAAA,EAEd;AAAA,EAES;AAAA,EAEA,eAAe,oBAAI,IAAmE;AAAA,EAEtF,WAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAe7B,YAAY,OAAoC,QAA4C;AAC1F,UAAM,oBAAoB,KAAK,CAAC;AAEhC,SAAK,MAAM,OAAO,IAAI;AACtB,SAAK,WAAW,QAAQ,WAAW;AACnC,SAAK,UAAU;AAEf,SAAK,gBAAgB,IAAI;AACzB,SAAK,cAAc,KAAK;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,IAAa,eAAyB;AACpC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAa,aAAa,UAAoB;AAC5C,SAAK,gBAAgB;AACrB,SAAK,cAAc,OAAO;AAAA,EAC5B;AAAA,EAEA,IAAa,SAAqB;AAChC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,IAAa,QAAkB;AAC7B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAa,MAAM,UAAoB;AACrC,QAAI,aAAa,KAAK,QAAQ;AAC5B;AAAA,IACF;AAEA,UAAM,WAAW,KAAK;AACtB,SAAK,SAAS;AACd,SAAK,OAAO,EAAE,QAAQ;AACtB,SAAK,iBAAiB,EAAE,EAAE,MAAM,MAAM;AAAA,IAAC,CAAC;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,aAAsB;AACxB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,aAAsB;AACxB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,KAAK,OAA0C;AAC7C,QAAI,UAAU,UAAa,UAAU,MAAM;AACzC,WAAK,MAAM;AACX;AAAA,IACF;AACA,SAAK,eAAe;AACpB;AAAA;AAAA,MAEE,KAAK;AAAA,MAEL,KAAK,gBAAgB,EAAE;AAAA;AAAA,MAGvB,KAAK,UAAU;AAAA,MACf;AACA,WAAK,OAAO,EAAE,KAAK,KAAK;AAAA,IAC1B;AAEA,SAAK,QAAQ,KAAK;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,SAAK,KAAK,KAAK,aAAa;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,SAAK,KAAK,KAAK,WAAW;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,SAA+C;AACnD,UAAM,WAAW,KAAK,SAAS;AAC/B,QAAI,UAAU;AACZ,aAAO,KAAK,SAAS,QAAQ;AAAA,IAC/B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,SAAY,gBAA6D;AAC7E,UAAM,SAAS,MAAM,KAAK,SAAS;AACnC,QAAI,OAAO,QAAQ;AACjB,YAAM,IAAI,gBAAgB,MAAM;AAAA,IAClC;AAEA,SAAK,cAAc;AACnB,SAAK,OAAO,EAAE,KAAK,KAAK;AACxB,SAAK,cAAc,OAAO;AAC1B,QAAI;AACF,aAAO,MAAM,eAAe,KAAK,KAAK,UAAU,KAAK,KAAK;AAAA,IAC5D,SAAS,OAAgB;AACvB,UAAI,iBAAiB,2BAA2B,MAAM,oBAAoB,QAAQ;AAChF,cAAM,cAAsC,CAAC;AAC7C,cAAM,oBAAoB,QAAQ,CAAC,SAA8B;AAC/D,gBAAM,MACJ,iGAAiG;AAAA,YAC/F,KAAK;AAAA,UACP;AACF,gBAAM,CAAC,UAAU,OAAO,OAAO,IAAI,MAAM,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,iBAAiB,IAAI,QAAW,KAAK,OAAO;AAC3G,sBAAY,KAAK;AAAA,YACf;AAAA,YACA;AAAA,YACA,WAAW,IAAI,gBAAgB,OAAO;AAAA,YACtC;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AACD,aAAK,yBAAyB,EAAE,WAAW;AAC3C,cAAM,IAAI,gBAAgB,WAAW;AAAA,MACvC;AAEA,YAAM;AAAA,IACR,UAAE;AACA,WAAK,cAAc;AACnB,WAAK,eAAe,KAAK;AACzB,WAAK,OAAO,EAAE,KAAK,KAAK;AAAA,IAC1B;AAAA,EACF;AAAA,EAEA,MAAM,kBACJ,OACA,WAC+C;AAC/C,QAAI;AAEJ,QAAI,KAAK,aAAa,IAAI,KAAK,GAAG;AAChC,yBAAmB,KAAK,aAAa,IAAI,KAAK;AAAA,IAIhD,OAAO;AACL,yBAAmB,oBAAI,IAAI;AAC3B,WAAK,aAAa,IAAI,OAAO,gBAAgB;AAAA,IAC/C;AAEA,UAAM,KAAK,kBAAkB;AAE7B,QAAI,iBAAiB,IAAI,SAAS,GAAG;AACnC,aAAO,iBAAiB,IAAI,SAAS;AAAA,IACvC;AAEA,UAAM,UAAU,aAAa,OAAO,WAAW,KAAK,YAAY,0BAA0B;AAC1F,qBAAiB,IAAI,WAAW,OAAO;AACvC,UAAM,cAAc,MAAM;AAE1B,qBAAiB,OAAO,SAAS;AACjC,QAAI,iBAAiB,SAAS,GAAG;AAC/B,WAAK,aAAa,OAAO,KAAK;AAAA,IAChC;AACA,QAAI,KAAK,aAAa,SAAS,GAAG;AAChC,WAAK,mBAAmB;AAAA,IAC1B;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,iBAAyB,KAAkB,OAA8C;AACvF,WAAO,wBAAwB,KAAqB,KAAK;AAAA,EAC3D;AAAA,EAEU,oBAA0C;AAClD,QAAI,CAAC,KAAK,oBAAoB;AAC5B,WAAK,cAAc;AACnB,WAAK,cAAc,OAAO;AAC1B,WAAK,qBAAqB,QAAQ,QAAQ,EAAE,KAAK,MAAM;AACrD,aAAK,qBAAqB;AAAA,MAC5B,CAAC;AAAA,IACH;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAEU,qBAA2B;AACnC,SAAK,cAAc;AACnB,SAAK,cAAc,OAAO;AAAA,EAC5B;AAAA,EAEA,CAAoB,OAAO,EAAE,UAA0B;AACrD,SAAK,SAAS,UAAU,KAAK,KAAK,UAAU,QAAQ;AACpD,SAAK,cAAc,OAAO;AAAA,EAC5B;AACF;",
  "names": []
}
