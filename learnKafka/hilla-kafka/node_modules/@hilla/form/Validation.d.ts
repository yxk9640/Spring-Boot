import type { BinderNode } from './BinderNode.js';
import type { BinderRoot } from './BinderRoot.js';
import { type AbstractModel, type Value } from './Models.js';
export interface ValueError<T = unknown> {
    property: AbstractModel | string;
    message: string;
    value: T;
    validator: Validator<T>;
}
export interface ValidationResult {
    property: AbstractModel | string;
    message?: string;
}
export declare class ValidationError extends Error {
    errors: readonly ValueError[];
    constructor(errors: readonly ValueError[]);
}
export type InterpolateMessageCallback<M extends AbstractModel> = (message: string, validator: Validator<Value<M>>, binderNode: BinderNode<M>) => string;
export interface Validator<T = unknown> {
    message: string;
    impliesRequired?: boolean;
    name?: string;
    validate(value: T, binder: BinderRoot): Promise<ValidationResult | boolean | readonly ValidationResult[]> | ValidationResult | boolean | readonly ValidationResult[];
}
export declare class ServerValidator implements Validator {
    name: string;
    message: string;
    constructor(message: string);
    validate: () => boolean;
}
export declare function runValidator<M extends AbstractModel>(model: M, validator: Validator<Value<M>>, interpolateMessageCallback?: InterpolateMessageCallback<M>): Promise<ReadonlyArray<ValueError<Value<M>>>>;
//# sourceMappingURL=Validation.d.ts.map