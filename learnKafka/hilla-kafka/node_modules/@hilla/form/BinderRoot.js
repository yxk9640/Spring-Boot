import { EndpointValidationError } from "@hilla/frontend/EndpointErrors.js";
import {
  _clearValidation,
  _setErrorsWithDescendants,
  _update,
  _updateValidation,
  BinderNode,
  CHANGED
} from "./BinderNode.js";
import { getDefaultFieldStrategy } from "./Field.js";
import {
  _parent,
  createDetachedModel
} from "./Models.js";
import {
  runValidator,
  ServerValidator,
  ValidationError
} from "./Validation.js";
class BinderRoot extends BinderNode {
  static interpolateMessageCallback;
  #defaultValue;
  // Initialized in the `read()` method
  #value;
  // Initialized in the `read()` method
  #emptyValue;
  #submitting = false;
  #validating = false;
  #validationRequest;
  #config;
  #validations = /* @__PURE__ */ new Map();
  #context = this;
  /**
   *
   * @param Model - The constructor (the class reference) of the form model. The Binder instantiates the top-level model
   * @param config - The options object, which can be used to config the onChange and onSubmit callbacks.
   *
   * ```
   * binder = new BinderRoot(OrderModel);
   * or
   * binder = new BinderRoot(OrderModel, {onSubmit: async (order) => {endpoint.save(order)}});
   * ```
   */
  constructor(Model, config) {
    super(createDetachedModel(Model));
    this.model[_parent] = this;
    this.#context = config?.context ?? this;
    this.#config = config;
    this.initializeValue(true);
    this.#emptyValue = this.value;
  }
  /**
   * The initial value of the form, before any fields are edited by the user.
   */
  get defaultValue() {
    return this.#defaultValue;
  }
  set defaultValue(newValue) {
    this.#defaultValue = newValue;
    this.dispatchEvent(CHANGED);
  }
  get binder() {
    return this;
  }
  /**
   * The current value of the form.
   */
  get value() {
    return this.#value;
  }
  set value(newValue) {
    if (newValue === this.#value) {
      return;
    }
    const oldValue = this.#value;
    this.#value = newValue;
    this[_update](oldValue);
    this[_updateValidation]().catch(() => {
    });
  }
  /**
   * Indicates the submitting status of the form.
   * True if the form was submitted, but the submit promise is not resolved yet.
   */
  get submitting() {
    return this.#submitting;
  }
  /**
   * Indicates the validating status of the form.
   * True when there is an ongoing validation.
   */
  get validating() {
    return this.#validating;
  }
  /**
   * Read the given value into the form and clear validation errors. Clears the form if the value is undefined.
   *
   * @param value - The value to read, or undefined to clear.
   */
  read(value) {
    if (value === void 0 || value === null) {
      this.clear();
      return;
    }
    this.defaultValue = value;
    if (
      // Skip when no value is set yet (e.g., invoked from constructor)
      this.value && // Clear validation state, then proceed if update is needed
      this[_clearValidation]() && // When value is dirty, another update is coming from invoking the value
      // setter below, so we skip this one to prevent duplicate updates
      this.value === value
    ) {
      this[_update](this.value);
    }
    this.value = this.defaultValue;
  }
  /**
   * Reset the form to the previous value
   */
  reset() {
    this.read(this.#defaultValue);
  }
  /**
   * Sets the form to empty value, as defined in the Model.
   */
  clear() {
    this.read(this.#emptyValue);
  }
  /**
   * Submit the current form value to a predefined
   * onSubmit callback.
   *
   * It's a no-op if the onSubmit callback is undefined.
   */
  async submit() {
    const onSubmit = this.#config?.onSubmit;
    if (onSubmit) {
      return this.submitTo(onSubmit);
    }
    return void 0;
  }
  /**
   * Submit the current form value to callback
   *
   * @param endpointMethod - the callback function
   */
  async submitTo(endpointMethod) {
    const errors = await this.validate();
    if (errors.length) {
      throw new ValidationError(errors);
    }
    this.#submitting = true;
    this[_update](this.value);
    this.dispatchEvent(CHANGED);
    try {
      return await endpointMethod.call(this.#context, this.value);
    } catch (error) {
      if (error instanceof EndpointValidationError && error.validationErrorData.length) {
        const valueErrors = [];
        error.validationErrorData.forEach((data) => {
          const res = /Object of type '(.+)' has invalid property '(.+)' with value '(.+)', validation error: '(.+)'/u.exec(
            data.message
          );
          const [property, value, message] = res ? res.splice(2) : [data.parameterName ?? "", void 0, data.message];
          valueErrors.push({
            message,
            property,
            validator: new ServerValidator(message),
            value
          });
        });
        this[_setErrorsWithDescendants](valueErrors);
        throw new ValidationError(valueErrors);
      }
      throw error;
    } finally {
      this.#submitting = false;
      this.defaultValue = this.value;
      this[_update](this.value);
    }
  }
  async requestValidation(model, validator) {
    let modelValidations;
    if (this.#validations.has(model)) {
      modelValidations = this.#validations.get(model);
    } else {
      modelValidations = /* @__PURE__ */ new Map();
      this.#validations.set(model, modelValidations);
    }
    await this.performValidation();
    if (modelValidations.has(validator)) {
      return modelValidations.get(validator);
    }
    const promise = runValidator(model, validator, this.constructor.interpolateMessageCallback);
    modelValidations.set(validator, promise);
    const valueErrors = await promise;
    modelValidations.delete(validator);
    if (modelValidations.size === 0) {
      this.#validations.delete(model);
    }
    if (this.#validations.size === 0) {
      this.completeValidation();
    }
    return valueErrors;
  }
  /**
   * Determines and returns the field directive strategy for the bound element.
   * Override to customise the binding strategy for a component.
   * The Binder extends BinderNode, see the inherited properties and methods below.
   *
   * @param elm - the bound element
   * @param model - the bound model
   */
  getFieldStrategy(elm, model) {
    return getDefaultFieldStrategy(elm, model);
  }
  performValidation() {
    if (!this.#validationRequest) {
      this.#validating = true;
      this.dispatchEvent(CHANGED);
      this.#validationRequest = Promise.resolve().then(() => {
        this.#validationRequest = void 0;
      });
    }
    return this.#validationRequest;
  }
  completeValidation() {
    this.#validating = false;
    this.dispatchEvent(CHANGED);
  }
  [_update](oldValue) {
    this.#config?.onChange?.call(this.#context, oldValue);
    this.dispatchEvent(CHANGED);
  }
}
export {
  BinderRoot
};
//# sourceMappingURL=BinderRoot.js.map
