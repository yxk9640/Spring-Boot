import type { Validator } from './Validation.js';
interface ValidatorAttributes {
    message?: string;
}
interface ValueNumberAttributes extends ValidatorAttributes {
    value: number | string;
}
interface DigitAttributes extends ValidatorAttributes {
    integer: number;
    fraction: number;
}
interface SizeAttributes extends ValidatorAttributes {
    min?: number;
    max?: number;
}
interface PatternAttributes extends ValidatorAttributes {
    regexp: RegExp | string;
}
interface DecimalAttributes extends ValueNumberAttributes {
    inclusive?: boolean;
}
declare abstract class AbstractValidator<T> implements Validator<T> {
    message: string;
    impliesRequired: boolean;
    constructor(attrs?: ValidatorAttributes);
    abstract validate(value: T): Promise<boolean> | boolean;
    abstract get name(): string;
}
export declare class Required<T> extends AbstractValidator<T> {
    impliesRequired: boolean;
    validate(value: T): boolean;
    readonly name: string;
}
declare abstract class NumberValidator<T> extends AbstractValidator<T> {
    validate(value: T): boolean;
}
export declare class IsNumber extends NumberValidator<number | null | undefined> {
    optional: boolean;
    constructor(optional: boolean, attrs?: ValidatorAttributes);
    validate(value: number | null | undefined): boolean;
    readonly name = "IsNumber";
}
declare abstract class ValueNumberValidator<T> extends NumberValidator<T> {
    value: number;
    protected constructor(attrs: ValueNumberAttributes | number | string);
}
export declare class Email extends AbstractValidator<string> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: string | null | undefined): boolean;
    readonly name = "Email";
}
export declare class Null extends AbstractValidator<any> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: any): boolean;
    readonly name = "Null";
}
export declare class NotNull<T> extends Required<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): value is NonNullable<T>;
    readonly name = "NotNull";
}
export declare class NotEmpty<T> extends Required<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "NotEmpty";
}
export declare class NotBlank<T> extends Required<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "NotBlank";
}
export declare class AssertTrue<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "AssertTrue";
}
export declare class AssertFalse<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "AssertFalse";
}
export declare class Min<T> extends ValueNumberValidator<T> {
    constructor(attrs: ValueNumberAttributes | number | string);
    validate(value: T): boolean;
    readonly name = "Min";
}
export declare class Max<T> extends ValueNumberValidator<T> {
    constructor(attrs: ValueNumberAttributes | number | string);
    validate(value: T): boolean;
    readonly name = "Max";
}
export declare class DecimalMin<T> extends ValueNumberValidator<T> {
    inclusive: boolean;
    constructor(attrs: DecimalAttributes | number | string);
    validate(value: T): boolean;
    readonly name = "DecimalMin";
}
export declare class DecimalMax<T> extends ValueNumberValidator<T> {
    inclusive: boolean;
    constructor(attrs: DecimalAttributes | number | string);
    validate(value: T): boolean;
    readonly name = "DecimalMax";
}
export declare class Negative<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "Negative";
}
export declare class NegativeOrZero<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "NegativeOrZero";
}
export declare class Positive<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "Positive";
}
export declare class PositiveOrZero<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "PositiveOrZero";
}
export declare class Size extends AbstractValidator<string> {
    min: number;
    max: number;
    constructor(attrs?: SizeAttributes);
    validate(value: string): boolean;
    readonly name = "Size";
}
export declare class Digits<T> extends AbstractValidator<T> {
    integer: number;
    fraction: number;
    constructor(attrs: DigitAttributes);
    validate(value: T): boolean;
    readonly name = "Digits";
}
export declare class Past<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "Past";
}
export declare class Future<T> extends AbstractValidator<T> {
    constructor(attrs?: ValidatorAttributes);
    validate(value: T): boolean;
    readonly name = "Future";
}
export declare class Pattern extends AbstractValidator<string> {
    regexp: RegExp;
    constructor(attrs: PatternAttributes | RegExp | string);
    validate(value: any): boolean;
    readonly name = "Pattern";
}
/**
 * Validator that reports an error when the bound HTML element validation
 * returns false from `element.checkValidity()` and `element.validity.valid`.
 */
export declare class ValidityStateValidator<T> extends AbstractValidator<T> {
    message: string;
    constructor();
    validate(): boolean;
    readonly name = "ValidityStateValidator";
}
export {};
//# sourceMappingURL=Validators.d.ts.map