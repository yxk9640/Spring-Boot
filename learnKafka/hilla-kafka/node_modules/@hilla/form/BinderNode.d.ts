import type { BinderRoot } from './BinderRoot.js';
import { AbstractModel, type ArrayItemModel, type Value } from './Models.js';
import type { ClassStaticProperties } from './types.js';
import type { Validator, ValueError } from './Validation.js';
import { _validity } from './Validity.js';
export declare const _updateValidation: unique symbol;
export declare const _update: unique symbol;
export declare const _setErrorsWithDescendants: unique symbol;
export declare const _clearValidation: unique symbol;
export declare function getBinderNode<M extends AbstractModel>(model: M): BinderNode<M>;
export declare const CHANGED: Event;
/**
 * The BinderNode\<M\> class provides the form binding related APIs
 * with respect to a particular model instance.
 *
 * Structurally, model instances form a tree, in which the object
 * and array models have child nodes of field and array item model
 * instances.
 */
export declare class BinderNode<M extends AbstractModel = AbstractModel> extends EventTarget {
    #private;
    readonly ['constructor']: ClassStaticProperties<typeof BinderNode<M>>;
    readonly model: M;
    /**
     * The validity state read from the bound element, if any. Represents the
     * HTML element internal validation.
     *
     * For elements with `validity.valid === false`, the value in the
     * bound element is considered as invalid.
     */
    [_validity]?: ValidityState;
    constructor(model: M);
    /**
     * The binder for the top-level model.
     */
    get binder(): BinderRoot;
    /**
     * The default value related to the model
     */
    get defaultValue(): Value<M> | undefined;
    /**
     * True if the current value is different from the defaultValue.
     */
    get dirty(): boolean;
    /**
     * The combined array of all errors for this nodeâ€™s model and all its nested
     * models
     */
    get errors(): readonly ValueError[];
    /**
     * Indicates if there is any error for the node's model.
     */
    get invalid(): boolean;
    /**
     * The name generated from the model structure, used to set the name
     * attribute on the field components.
     */
    get name(): string;
    /**
     * The array of validation errors directly related with the model.
     */
    get ownErrors(): ReadonlyArray<ValueError<Value<M>>>;
    /**
     * The parent node, if this binder node corresponds to a nested model,
     * otherwise undefined for the top-level binder.
     */
    get parent(): BinderNode | undefined;
    /**
     * True if the value is required to be non-empty.
     */
    get required(): boolean;
    /**
     * The array of validators for the model. The default value is defined in the
     * model.
     */
    get validators(): ReadonlyArray<Validator<Value<M>>>;
    set validators(validators: ReadonlyArray<Validator<Value<M>>>);
    /**
     * The current value related to the model
     */
    get value(): Value<M> | undefined;
    set value(value: Value<M> | undefined);
    /**
     * True if the bound field was ever focused and blurred by the user.
     */
    get visited(): boolean;
    set visited(v: boolean);
    /**
     * A helper method to add a validator
     *
     * @param validator - a validator
     */
    addValidator(validator: Validator<Value<M>>): void;
    /**
     * Append an item to the array value.
     *
     * Requires the context model to be an array reference.
     *
     * @param item - optional new item value, an empty item is
     * appended if the argument is omitted
     */
    appendItem(item?: Value<ArrayItemModel<M>>): void;
    /**
     * Returns a binder node for the nested model instance.
     *
     * @param model - The nested model instance
     */
    for<N extends AbstractModel>(model: N): BinderNode<N>;
    prependItem(item?: Value<ArrayItemModel<M>>): void;
    removeSelf(): void;
    /**
     * Runs all validation callbacks potentially affecting this
     * or any nested model. Returns the combined array of all
     * errors as in the errors property.
     */
    validate(): Promise<readonly ValueError[]>;
    protected [_clearValidation](): boolean;
    protected [_setErrorsWithDescendants](errors?: readonly ValueError[]): void;
    protected [_update](_?: Value<M>): void;
    protected [_updateValidation](): Promise<void>;
    initializeValue(forceInitialize?: boolean): void;
}
//# sourceMappingURL=BinderNode.d.ts.map