{
  "version": 3,
  "sources": ["src/index.ts"],
  "sourcesContent": ["import Plugin from '@hilla/generator-typescript-core/Plugin.js';\nimport type SharedStorage from '@hilla/generator-typescript-core/SharedStorage.js';\nimport type { OpenAPIV3 } from 'openapi-types';\nimport type { ReadonlyObjectDeep } from 'type-fest/source/readonly-deep';\nimport { type EndpointOperations, PushProcessor } from './PushProcessor.js';\n\ntype ExtendedMediaTypeSchema = Readonly<{ 'x-class-name': string }> &\n  ReadonlyObjectDeep<OpenAPIV3.ReferenceObject | OpenAPIV3.SchemaObject>;\n\nconst classesToReplace: readonly string[] = [\n  'dev.hilla.runtime.transfertypes.Flux',\n  'dev.hilla.runtime.transfertypes.EndpointSubscription',\n];\n\nexport default class PushPlugin extends Plugin {\n  /**\n   * Collects methods that must be patched by checking their `x-class-name` value\n   */\n  static #collectPatchableMethods(paths: ReadonlyObjectDeep<OpenAPIV3.PathsObject>) {\n    return Object.entries(paths).reduce((acc, [key, path]) => {\n      const response = path?.post?.responses[200] as ReadonlyObjectDeep<OpenAPIV3.ResponseObject> | undefined;\n      const schema = response?.content?.['application/json']?.schema as ExtendedMediaTypeSchema | undefined;\n      const className = schema?.['x-class-name'];\n      const [, endpoint, method] = key.split('/');\n\n      if (className && classesToReplace.includes(className)) {\n        if (acc.has(endpoint)) {\n          acc.get(endpoint)!.methodsToPatch.push(method);\n        } else {\n          acc.set(endpoint, { methodsToPatch: [method], removeInitImport: true });\n        }\n      } else {\n        // Not all methods will be patched, let's keep the init import\n        // eslint-disable-next-line no-lonely-if\n        if (acc.has(endpoint)) {\n          acc.get(endpoint)!.removeInitImport = false;\n        } else {\n          acc.set(endpoint, { methodsToPatch: [], removeInitImport: false });\n        }\n      }\n\n      return acc;\n    }, new Map<string, EndpointOperations>());\n  }\n\n  declare ['constructor']: typeof PushPlugin;\n\n  override get path(): string {\n    return import.meta.url;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  override async execute(storage: SharedStorage): Promise<void> {\n    const { api, sources } = storage;\n    const endpointMethodMap = this.constructor.#collectPatchableMethods(api.paths);\n\n    for (let i = 0; i < sources.length; i++) {\n      const { fileName } = sources[i];\n      const endpoint = fileName.substring(0, fileName.indexOf('.ts'));\n\n      if (endpointMethodMap.has(endpoint)) {\n        sources[i] = new PushProcessor(sources[i], endpointMethodMap.get(endpoint)!).process();\n      }\n    }\n  }\n}\n"],
  "mappings": "AAAA,OAAO,YAAY;AAInB,SAAkC,qBAAqB;AAKvD,MAAM,mBAAsC;AAAA,EAC1C;AAAA,EACA;AACF;AAEA,MAAO,mBAAiC,OAAO;AAAA;AAAA;AAAA;AAAA,EAI7C,OAAO,yBAAyB,OAAkD;AAChF,WAAO,OAAO,QAAQ,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,IAAI,MAAM;AACxD,YAAM,WAAW,MAAM,MAAM,UAAU,GAAG;AAC1C,YAAM,SAAS,UAAU,UAAU,kBAAkB,GAAG;AACxD,YAAM,YAAY,SAAS,cAAc;AACzC,YAAM,CAAC,EAAE,UAAU,MAAM,IAAI,IAAI,MAAM,GAAG;AAE1C,UAAI,aAAa,iBAAiB,SAAS,SAAS,GAAG;AACrD,YAAI,IAAI,IAAI,QAAQ,GAAG;AACrB,cAAI,IAAI,QAAQ,EAAG,eAAe,KAAK,MAAM;AAAA,QAC/C,OAAO;AACL,cAAI,IAAI,UAAU,EAAE,gBAAgB,CAAC,MAAM,GAAG,kBAAkB,KAAK,CAAC;AAAA,QACxE;AAAA,MACF,OAAO;AAGL,YAAI,IAAI,IAAI,QAAQ,GAAG;AACrB,cAAI,IAAI,QAAQ,EAAG,mBAAmB;AAAA,QACxC,OAAO;AACL,cAAI,IAAI,UAAU,EAAE,gBAAgB,CAAC,GAAG,kBAAkB,MAAM,CAAC;AAAA,QACnE;AAAA,MACF;AAEA,aAAO;AAAA,IACT,GAAG,oBAAI,IAAgC,CAAC;AAAA,EAC1C;AAAA,EAIA,IAAa,OAAe;AAC1B,WAAO,YAAY;AAAA,EACrB;AAAA;AAAA,EAGA,MAAe,QAAQ,SAAuC;AAC5D,UAAM,EAAE,KAAK,QAAQ,IAAI;AACzB,UAAM,oBAAoB,KAAK,YAAY,yBAAyB,IAAI,KAAK;AAE7E,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAM,EAAE,SAAS,IAAI,QAAQ,CAAC;AAC9B,YAAM,WAAW,SAAS,UAAU,GAAG,SAAS,QAAQ,KAAK,CAAC;AAE9D,UAAI,kBAAkB,IAAI,QAAQ,GAAG;AACnC,gBAAQ,CAAC,IAAI,IAAI,cAAc,QAAQ,CAAC,GAAG,kBAAkB,IAAI,QAAQ,CAAE,EAAE,QAAQ;AAAA,MACvF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": []
}
