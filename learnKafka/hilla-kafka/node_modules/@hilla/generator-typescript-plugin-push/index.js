import Plugin from "@hilla/generator-typescript-core/Plugin.js";
import { PushProcessor } from "./PushProcessor.js";
const classesToReplace = [
  "dev.hilla.runtime.transfertypes.Flux",
  "dev.hilla.runtime.transfertypes.EndpointSubscription"
];
class PushPlugin extends Plugin {
  /**
   * Collects methods that must be patched by checking their `x-class-name` value
   */
  static #collectPatchableMethods(paths) {
    return Object.entries(paths).reduce((acc, [key, path]) => {
      const response = path?.post?.responses[200];
      const schema = response?.content?.["application/json"]?.schema;
      const className = schema?.["x-class-name"];
      const [, endpoint, method] = key.split("/");
      if (className && classesToReplace.includes(className)) {
        if (acc.has(endpoint)) {
          acc.get(endpoint).methodsToPatch.push(method);
        } else {
          acc.set(endpoint, { methodsToPatch: [method], removeInitImport: true });
        }
      } else {
        if (acc.has(endpoint)) {
          acc.get(endpoint).removeInitImport = false;
        } else {
          acc.set(endpoint, { methodsToPatch: [], removeInitImport: false });
        }
      }
      return acc;
    }, /* @__PURE__ */ new Map());
  }
  get path() {
    return import.meta.url;
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async execute(storage) {
    const { api, sources } = storage;
    const endpointMethodMap = this.constructor.#collectPatchableMethods(api.paths);
    for (let i = 0; i < sources.length; i++) {
      const { fileName } = sources[i];
      const endpoint = fileName.substring(0, fileName.indexOf(".ts"));
      if (endpointMethodMap.has(endpoint)) {
        sources[i] = new PushProcessor(sources[i], endpointMethodMap.get(endpoint)).process();
      }
    }
  }
}
export {
  PushPlugin as default
};
//# sourceMappingURL=index.js.map
