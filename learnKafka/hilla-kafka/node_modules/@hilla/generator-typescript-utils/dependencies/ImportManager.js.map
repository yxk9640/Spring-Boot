{
  "version": 3,
  "sources": ["../src/dependencies/ImportManager.ts"],
  "sourcesContent": ["import ts, { type Identifier, type ImportDeclaration, type Statement } from 'typescript';\nimport createFullyUniqueIdentifier from '../createFullyUniqueIdentifier.js';\nimport type CodeConvertable from './CodeConvertable.js';\nimport StatementRecordManager, { type StatementRecord } from './StatementRecordManager.js';\nimport { createDependencyRecord, type DependencyRecord } from './utils.js';\n\nexport class NamedImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #collator: Intl.Collator;\n  readonly #map = new Map<string, Map<string, DependencyRecord>>();\n\n  constructor(collator: Intl.Collator) {\n    super(collator);\n    this.#collator = collator;\n  }\n\n  add(path: string, specifier: string, isType?: boolean, uniqueId?: Identifier): Identifier {\n    const record = createDependencyRecord(uniqueId ?? createFullyUniqueIdentifier(specifier), isType);\n\n    if (this.#map.has(path)) {\n      this.#map.get(path)!.set(specifier, record);\n    } else {\n      this.#map.set(path, new Map([[specifier, record]]));\n    }\n\n    return record.id;\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  getIdentifier(path: string, specifier: string): Identifier | undefined {\n    return this.#map.get(path)?.get(specifier)?.id;\n  }\n\n  *identifiers(): IterableIterator<readonly [path: string, specifier: string, id: Identifier, isType: boolean]> {\n    for (const [path, specifiers] of this.#map) {\n      for (const [specifier, { id, isType }] of specifiers) {\n        yield [path, specifier, id, isType];\n      }\n    }\n  }\n\n  isType(path: string, specifier: string): boolean | undefined {\n    return this.#map.get(path)?.get(specifier)?.isType;\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  *specifiers(): IterableIterator<readonly [path: string, specifier: string]> {\n    for (const [path, specifiers] of this.#map) {\n      for (const specifier of specifiers.keys()) {\n        yield [path, specifier];\n      }\n    }\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, specifiers] of this.#map) {\n      const names = [...specifiers.keys()];\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      names.sort(this.#collator.compare);\n\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(\n            false,\n            undefined,\n            ts.factory.createNamedImports(\n              names.map((name) => {\n                const { id, isType } = specifiers.get(name)!;\n                return ts.factory.createImportSpecifier(isType, ts.factory.createIdentifier(name), id);\n              }),\n            ),\n          ),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n}\n\nexport class NamespaceImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #map = new Map<string, Identifier>();\n\n  add(path: string, name: string, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(path, id);\n    return id;\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  getIdentifier(path: string): Identifier | undefined {\n    return this.#map.get(path);\n  }\n\n  *identifiers(): IterableIterator<Identifier> {\n    for (const id of this.#map.values()) {\n      yield id;\n    }\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, id] of this.#map) {\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(false, undefined, ts.factory.createNamespaceImport(id)),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n}\n\nexport class DefaultImportManager extends StatementRecordManager<ImportDeclaration> {\n  readonly #map = new Map<string, DependencyRecord>();\n\n  add(path: string, name: string, isType?: boolean, uniqueId?: Identifier): Identifier {\n    const id = uniqueId ?? createFullyUniqueIdentifier(name);\n    this.#map.set(path, createDependencyRecord(id, isType));\n    return id;\n  }\n\n  getIdentifier(path: string): Identifier | undefined {\n    return this.#map.get(path)?.id;\n  }\n\n  override clear(): void {\n    this.#map.clear();\n  }\n\n  *identifiers(): IterableIterator<readonly [id: Identifier, isType: boolean]> {\n    for (const { id, isType } of this.#map.values()) {\n      yield [id, isType];\n    }\n  }\n\n  isType(path: string): boolean | undefined {\n    return this.#map.get(path)?.isType;\n  }\n\n  paths(): IterableIterator<string> {\n    return this.#map.keys();\n  }\n\n  override *statementRecords(): IterableIterator<StatementRecord<ImportDeclaration>> {\n    for (const [path, { id, isType }] of this.#map) {\n      yield [\n        path,\n        ts.factory.createImportDeclaration(\n          undefined,\n          ts.factory.createImportClause(isType, id, undefined),\n          ts.factory.createStringLiteral(path),\n        ),\n      ];\n    }\n  }\n}\n\nexport default class ImportManager implements CodeConvertable<readonly Statement[]> {\n  readonly default: DefaultImportManager;\n  readonly named: NamedImportManager;\n  readonly namespace: NamespaceImportManager;\n\n  readonly #collator: Intl.Collator;\n\n  constructor(collator: Intl.Collator) {\n    this.default = new DefaultImportManager(collator);\n    this.named = new NamedImportManager(collator);\n    this.namespace = new NamespaceImportManager(collator);\n    this.#collator = collator;\n  }\n\n  toCode(): readonly Statement[] {\n    const records = [\n      ...this.default.statementRecords(),\n      ...this.named.statementRecords(),\n      ...this.namespace.statementRecords(),\n    ];\n    records.sort(StatementRecordManager.createComparator(this.#collator));\n\n    return records.map(([, statement]) => statement);\n  }\n\n  fromCode(source: ts.SourceFile): void {\n    this.default.clear();\n    this.named.clear();\n    this.namespace.clear();\n\n    const imports = source.statements.filter((statement): statement is ImportDeclaration =>\n      ts.isImportDeclaration(statement),\n    );\n\n    for (const { importClause, moduleSpecifier } of imports) {\n      if (!importClause) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const { name, namedBindings } = importClause;\n      const path = (moduleSpecifier as ts.StringLiteral).text;\n\n      if (namedBindings) {\n        if (ts.isNamespaceImport(namedBindings)) {\n          this.namespace.add(path, namedBindings.name.text, namedBindings.name);\n        } else {\n          for (const { isTypeOnly, name: specifier } of namedBindings.elements) {\n            this.named.add(path, specifier.text, isTypeOnly, specifier);\n          }\n        }\n      } else if (name) {\n        this.default.add(path, name.text, importClause.isTypeOnly, name);\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
